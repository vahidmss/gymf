// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:app_links_web/app_links_web.dart';
import 'package:google_sign_in_web/google_sign_in_web.dart';
import 'package:image_picker_for_web/image_picker_for_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:url_launcher_web/url_launcher_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  AppLinksPluginWeb.registerWith(registrar);
  GoogleSignInPlugin.registerWith(registrar);
  ImagePickerPlugin.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  UrlLauncherPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.7

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:google_sign_in_android/google_sign_in_android.dart';
import 'package:image_picker_android/image_picker_android.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:url_launcher_android/url_launcher_android.dart';
import 'package:google_sign_in_ios/google_sign_in_ios.dart';
import 'package:image_picker_ios/image_picker_ios.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:url_launcher_ios/url_launcher_ios.dart';
import 'package:app_links_linux/app_links_linux.dart';
import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:file_selector_macos/file_selector_macos.dart';
import 'package:google_sign_in_ios/google_sign_in_ios.dart';
import 'package:image_picker_macos/image_picker_macos.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:url_launcher_macos/url_launcher_macos.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        GoogleSignInAndroid.registerWith();
      } catch (err) {
        print(
          '`google_sign_in_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerAndroid.registerWith();
      } catch (err) {
        print(
          '`image_picker_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherAndroid.registerWith();
      } catch (err) {
        print(
          '`url_launcher_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        GoogleSignInIOS.registerWith();
      } catch (err) {
        print(
          '`google_sign_in_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerIOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherIOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        AppLinksPluginLinux.registerWith();
      } catch (err) {
        print(
          '`app_links_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        FileSelectorLinux.registerWith();
      } catch (err) {
        print(
          '`file_selector_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerLinux.registerWith();
      } catch (err) {
        print(
          '`image_picker_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherLinux.registerWith();
      } catch (err) {
        print(
          '`url_launcher_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FileSelectorMacOS.registerWith();
      } catch (err) {
        print(
          '`file_selector_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        GoogleSignInIOS.registerWith();
      } catch (err) {
        print(
          '`google_sign_in_ios` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`image_picker_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherMacOS.registerWith();
      } catch (err) {
        print(
          '`url_launcher_macos` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FileSelectorWindows.registerWith();
      } catch (err) {
        print(
          '`file_selector_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        ImagePickerWindows.registerWith();
      } catch (err) {
        print(
          '`image_picker_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        UrlLauncherWindows.registerWith();
      } catch (err) {
        print(
          '`url_launcher_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}

import 'package:gymf/data/models/exercise_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ExerciseService {
  final SupabaseClient supabase = Supabase.instance.client;

  Future<void> addExercise(ExerciseModel exercise) async {
    await Supabase.instance.client.from('exercises').insert({
      'id': exercise.id,
      'name': exercise.name,
      'category': exercise.category,
      'type': exercise.type,
      'coach_username': exercise.coachUsername,
      'description': exercise.description,
      'image_url': exercise.imageUrl,
      'video_url': exercise.videoUrl,
      'created_at': exercise.createdAt.toIso8601String(),
    });
  }

  Future<List<ExerciseModel>> getExercises() async {
    try {
      final response = await supabase.from('exercises').select();
      return response.map((e) => ExerciseModel.fromMap(e)).toList();
    } catch (e, stacktrace) {
      print('ًں”´ ط®ط·ط§ ط¯ط± ط¯ط±غŒط§ظپطھ طھظ…ط±غŒظ†ط§طھ: $e');
      print('ًں”چ ط¬ط²ط¦غŒط§طھ ط¨غŒط´طھط±: $stacktrace');
      return [];
    }
  }

  Future<bool> updateExercise(String id, Map<String, dynamic> updates) async {
    try {
      await supabase.from('exercises').update(updates).match({'id': id});
      return true;
    } catch (e, stacktrace) {
      print('ًں”´ ط®ط·ط§ ط¯ط± ط¨ط±ظˆط²ط±ط³ط§ظ†غŒ طھظ…ط±غŒظ†: $e');
      print('ًں”چ ط¬ط²ط¦غŒط§طھ ط¨غŒط´طھط±: $stacktrace');
      return false;
    }
  }

  Future<bool> deleteExercise(String id) async {
    try {
      await supabase.from('exercises').delete().match({'id': id});
      return true;
    } catch (e, stacktrace) {
      print('ًں”´ ط®ط·ط§ ط¯ط± ط­ط°ظپ طھظ…ط±غŒظ†: $e');
      print('ًں”چ ط¬ط²ط¦غŒط§طھ ط¨غŒط´طھط±: $stacktrace');
      return false;
    }
  }
}
import 'package:http/http.dart' as http;
import 'dart:convert';

class OtpService {
  static const String apiKey = '04cce60c3b6c447783c27264975f4580';

  Future<String> sendOtp(String phone) async {
    if (!isValidIranianPhoneNumber(phone)) {
      throw Exception(
        'ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„ ظ†ط§ظ…ط¹طھط¨ط± ط§ط³طھ. ظ„ط·ظپط§ظ‹ ط´ظ…ط§ط±ظ‡â€Œط§غŒ ط¨ط§ ظپط±ظ…طھ 09XXXXXXXXX ظˆط§ط±ط¯ ع©ظ†غŒط¯.',
      );
    }

    final formattedPhone = phone.startsWith('09') ? phone : '0$phone';

    final response = await http.post(
      Uri.parse('https://console.melipayamak.com/api/send/otp/$apiKey'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({'to': formattedPhone}),
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data['status'] == 'success' || data['status'].isEmpty) {
        return data['code'];
      } else {
        throw Exception('Failed to send OTP: ${data['status']}');
      }
    } else {
      throw Exception('Failed to send OTP: ${response.body}');
    }
  }

  bool isValidIranianPhoneNumber(String phone) {
    if (phone.length == 11 && phone.startsWith('09')) {
      return RegExp(r'^[0-9]+$').hasMatch(phone);
    } else if (phone.length == 12 && phone.startsWith('+989')) {
      return RegExp(r'^\+989[0-9]{9}$').hasMatch(phone);
    }
    return false;
  }
}
bool isValidIranianPhoneNumber(String phone) {
  // ط¨ط±ط±ط³غŒ ع©ظ†غŒط¯ ع©ظ‡ ط´ظ…ط§ط±ظ‡ 11 ط±ظ‚ظ…غŒ ظˆ ط¨ط§ 09 ط´ط±ظˆط¹ ط¨ط´ظ‡
  if (phone.length != 11 || !phone.startsWith('09')) {
    return false;
  }
  // ظپظ‚ط· ط¹ط¯ط¯ ط¨ط§ط´ظ‡
  return RegExp(r'^[0-9]+$').hasMatch(phone);
}
class Coach {
  final String id;
  final String name;
  final String imageUrl;
  final int experienceYears;
  final int trainees;
  final int achievements;

  Coach({
    required this.id,
    required this.name,
    required this.imageUrl,
    required this.experienceYears,
    required this.trainees,
    required this.achievements,
  });

  factory Coach.fromMap(Map<String, dynamic> data) {
    return Coach(
      id: data['id'] ?? '',
      name: data['name'] ?? 'ط¨ط¯ظˆظ† ظ†ط§ظ…',
      imageUrl: data['imageUrl'] ?? '',
      experienceYears: data['experienceYears'] ?? 0,
      trainees: data['trainees'] ?? 0,
      achievements: data['achievements'] ?? 0,
    );
  }
}
import 'package:uuid/uuid.dart';

class ExerciseModel {
  final String id;
  final String category;
  final String type;
  final String name;
  final String coachUsername;
  final String? description;
  final String? imageUrl;
  final String? videoUrl;
  final DateTime createdAt;

  ExerciseModel({
    String? id,
    required this.category,
    required this.type,
    required this.name,
    required this.coachUsername,
    this.description,
    this.imageUrl,
    this.videoUrl,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(), // ط§ع¯ط± id ظ…ظ‚ط¯ط§ط± ظ†ط¯ط§ط´طھطŒ UUID ط¬ط¯غŒط¯ ط¨ط³ط§ط²
       createdAt = createdAt ?? DateTime.now(); // ظ…ظ‚ط¯ط§ط± ظ¾غŒط´â€Œظپط±ط¶ ط¨ط±ط§غŒ createdAt

  // طھط¨ط¯غŒظ„ ط§ط² Map ط¨ظ‡ ظ…ط¯ظ„
  factory ExerciseModel.fromMap(Map<String, dynamic> map) {
    return ExerciseModel(
      id: map['id'] as String,
      category: map['category'] as String,
      type: map['type'] as String,
      name: map['name'] as String,
      coachUsername: map['coach_username'] as String,
      description: map['description'] as String?,
      imageUrl: map['image_url'] as String?,
      videoUrl: map['video_url'] as String?,
      createdAt:
          DateTime.tryParse(map['created_at'] as String) ?? DateTime.now(),
    );
  }

  // طھط¨ط¯غŒظ„ ظ…ط¯ظ„ ط¨ظ‡ JSON ط¨ط±ط§غŒ ط°ط®غŒط±ظ‡ ط¯ط± ط¯غŒطھط§ط¨غŒط³
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'category': category,
      'type': type,
      'name': name,
      'coach_username': coachUsername,
      'description': description,
      'image_url': imageUrl,
      'video_url': videoUrl,
      'created_at': createdAt.toIso8601String(),
    };
  }
}
import 'package:uuid/uuid.dart';

class LogSetModel {
  String id;
  String logId;
  int setNumber;
  int weight;
  int reps;
  DateTime createdAt;

  LogSetModel({
    String? id,
    required this.logId,
    required this.setNumber,
    this.weight = 0,
    this.reps = 0,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory LogSetModel.fromJson(Map<String, dynamic> json) => LogSetModel(
    id: json['id'],
    logId: json['log_id'],
    setNumber: json['set_number'],
    weight: json['weight'] ?? 0,
    reps: json['reps'] ?? 0,
    createdAt: DateTime.parse(json['created_at']),
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'log_id': logId,
    'set_number': setNumber,
    'weight': weight,
    'reps': reps,
    'created_at': createdAt.toIso8601String(),
  };
}
class UserModel {
  final String userId;
  final String phone;
  final String username;
  final String role;
  final bool isVerified;
  final DateTime createdAt;
  final String password;

  UserModel({
    required this.userId,
    required this.phone,
    required this.username,
    required this.role,
    required this.isVerified,
    required this.createdAt,
    required this.password,
  });

  factory UserModel.fromMap(Map<String, dynamic> map) {
    return UserModel(
      userId: map['id'] as String,
      phone: map['phone'] as String,
      username: map['username'] as String,
      role: map['role'] as String,
      isVerified: map['is_verified'] as bool,
      createdAt: DateTime.parse(map['created_at'] as String),
      password: map['password'] as String,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': userId,
      'phone': phone,
      'username': username,
      'role': role,
      'is_verified': isVerified,
      'created_at': createdAt.toIso8601String(),
      'password': password,
    };
  }

  UserModel copyWith({
    String? userId,
    String? phone,
    String? username,
    String? role,
    bool? isVerified,
    DateTime? createdAt,
    String? password,
  }) {
    return UserModel(
      userId: userId ?? this.userId,
      phone: phone ?? this.phone,
      username: username ?? this.username,
      role: role ?? this.role,
      isVerified: isVerified ?? this.isVerified,
      createdAt: createdAt ?? this.createdAt,
      password: password ?? this.password,
    );
  }
}
import 'package:uuid/uuid.dart';

class WorkoutExerciseModel {
  String id;
  String planId;
  String exerciseId;
  int sets;
  int? reps;
  int? duration;
  String? intensity;
  DateTime createdAt;

  WorkoutExerciseModel({
    String? id,
    required this.planId,
    required this.exerciseId,
    this.sets = 1,
    this.reps,
    this.duration,
    this.intensity,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory WorkoutExerciseModel.fromJson(Map<String, dynamic> json) =>
      WorkoutExerciseModel(
        id: json['id'],
        planId: json['plan_id'],
        exerciseId: json['exercise_id'],
        sets: json['sets'] ?? 1,
        reps: json['reps'],
        duration: json['duration'],
        intensity: json['intensity'],
        createdAt: DateTime.parse(json['created_at']),
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'plan_id': planId,
    'exercise_id': exerciseId,
    'sets': sets,
    'reps': reps,
    'duration': duration,
    'intensity': intensity,
    'created_at': createdAt.toIso8601String(),
  };
}
import 'package:uuid/uuid.dart';

class WorkoutLogModel {
  String id;
  String userId;
  String exerciseId;
  String planId;
  DateTime date;
  String? notes;

  WorkoutLogModel({
    String? id,
    required this.userId,
    required this.exerciseId,
    required this.planId,
    DateTime? date,
    this.notes,
  }) : id = id ?? const Uuid().v4(),
       date = date ?? DateTime.now();

  factory WorkoutLogModel.fromJson(Map<String, dynamic> json) =>
      WorkoutLogModel(
        id: json['id'],
        userId: json['user_id'],
        exerciseId: json['exercise_id'],
        planId: json['plan_id'],
        date: DateTime.parse(json['date']),
        notes: json['notes'],
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'user_id': userId,
    'exercise_id': exerciseId,
    'plan_id': planId,
    'date': date.toIso8601String(),
    'notes': notes,
  };
}
import 'package:uuid/uuid.dart';

class WorkoutPlanModel {
  String id;
  String userId;
  String? assignedTo;
  String day;
  String planName;
  DateTime createdAt;

  WorkoutPlanModel({
    String? id,
    required this.userId,
    this.assignedTo,
    required this.day,
    required this.planName,
    DateTime? createdAt,
  }) : id = id ?? const Uuid().v4(),
       createdAt = createdAt ?? DateTime.now();

  factory WorkoutPlanModel.fromJson(Map<String, dynamic> json) =>
      WorkoutPlanModel(
        id: json['id'],
        userId: json['user_id'],
        assignedTo: json['assigned_to'],
        day: json['day'],
        planName: json['plan_name'],
        createdAt: DateTime.parse(json['created_at']),
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'user_id': userId,
    'assigned_to': assignedTo,
    'day': day,
    'plan_name': planName,
    'created_at': createdAt.toIso8601String(),
  };
}
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../core/services/otp_service.dart';
import '../data/models/user_model.dart';
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:uuid/uuid.dart';
import 'dart:async';

class AuthProvider with ChangeNotifier {
  final SupabaseClient _supabase = Supabase.instance.client;
  final OtpService _otpService = OtpService();

  UserModel? _currentUser;
  UserModel? get currentUser => _currentUser;
  String? get userId => _supabase.auth.currentUser?.id;

  String? _otpCode;
  String? get otpCode => _otpCode;

  late StreamSubscription<AuthState> _authSubscription;

  /// ع†ع© ع©ط±ط¯ظ† ظˆط¶ط¹غŒطھ ظ„ط§ع¯غŒظ† ع©ط§ط±ط¨ط±
  Future<bool> checkAuthStatus() async {
    return _supabase.auth.currentSession != null;
  }

  /// طھظ†ط¸غŒظ… ع©ط¯ OTP
  void setOtpCode(String code) {
    _otpCode = code;
    notifyListeners();
  }

  /// ظ‡ط´ ع©ط±ط¯ظ† ط±ظ…ط² ط¹ط¨ظˆط±
  String _hashPassword(String password) {
    return sha256.convert(utf8.encode(password)).toString();
  }

  /// ط«ط¨طھâ€Œظ†ط§ظ… ط¨ط§ ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„ ظˆ OTP
  Future<void> signUpWithPhone(
    String phone,
    String username,
    String password,
    String role,
  ) async {
    try {
      if (!await isUsernameUnique(username)) {
        throw Exception('ط§غŒظ† غŒظˆط²ط±ظ†غŒظ… ظ‚ط¨ظ„ط§ظ‹ ط§ط³طھظپط§ط¯ظ‡ ط´ط¯ظ‡ ط§ط³طھ.');
      }

      await _otpService.sendOtp(phone);
      await _supabase.auth.signInWithOtp(phone: phone);

      final hashedPassword = _hashPassword(password);
      final userId = const Uuid().v4();

      _currentUser = UserModel(
        userId: userId,
        phone: phone,
        username: username,
        role: role,
        isVerified: false,
        createdAt: DateTime.now(),
        password: hashedPassword,
      );

      await saveUserData(_currentUser!); // ط°ط®غŒط±ظ‡ ظ…ظˆظ‚طھ ط¯ط± ط¯غŒطھط§ط¨غŒط³
    } catch (e) {
      throw Exception('ط®ط·ط§ ط¯ط± ط«ط¨طھâ€Œظ†ط§ظ…: $e');
    }
  }

  /// طھط£غŒغŒط¯ OTP ظˆ ظˆط±ظˆط¯
  Future<void> verifyOtp(String phone, String enteredCode) async {
    try {
      final authResponse = await _supabase.auth.verifyOTP(
        type: OtpType.sms,
        phone: phone,
        token: enteredCode,
      );

      final user = _supabase.auth.currentUser;
      if (user == null) {
        throw Exception('طھط£غŒغŒط¯ OTP ظ†ط§ظ…ظˆظپظ‚ ط¨ظˆط¯.');
      }

      _currentUser = await getUserDataByPhone(phone);
      if (_currentUser == null) {
        throw Exception('ع©ط§ط±ط¨ط± غŒط§ظپطھ ظ†ط´ط¯.');
      }

      _currentUser = _currentUser!.copyWith(isVerified: true);
      await saveUserData(_currentUser!);

      _otpCode = null;
      notifyListeners();
    } catch (e) {
      throw Exception('ط®ط·ط§ ط¯ط± طھط£غŒغŒط¯ ع©ط¯: $e');
    }
  }

  /// ظˆط±ظˆط¯ ط¨ط§ ع¯ظˆع¯ظ„
  Future<void> signInWithGoogle(BuildContext context) async {
    try {
      _authSubscription = _supabase.auth.onAuthStateChange.listen((data) async {
        final session = data.session;
        if (session == null) return;

        final user = session.user;
        final response =
            await _supabase
                .from('users')
                .select()
                .eq('id', user.id)
                .maybeSingle();

        if (response == null ||
            response['username'] == null ||
            response['role'] == null) {
          Navigator.pushReplacementNamed(context, '/complete-profile');
        } else {
          Navigator.pushReplacementNamed(context, '/dashboard');
        }

        _authSubscription.cancel();
      });

      await _supabase.auth.signInWithOAuth(
        OAuthProvider.google,
        redirectTo: 'gymf://auth/callback',
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text("ظ…ط´ع©ظ„غŒ ظ¾غŒط´ ط¢ظ…ط¯. ظ„ط·ظپط§ظ‹ ط¯ظˆط¨ط§ط±ظ‡ طھظ„ط§ط´ ع©ظ†غŒط¯.")),
      );
    }
  }

  /// ظˆط±ظˆط¯ ط¨ط§ غŒظˆط²ط±ظ†غŒظ… ظˆ ظ¾ط³ظˆط±ط¯
  Future<void> signInWithUsername(String username, String password) async {
    try {
      final userData = await getUserDataByUsername(username);
      if (userData == null || _hashPassword(password) != userData.password) {
        throw Exception('غŒظˆط²ط±ظ†غŒظ… غŒط§ ط±ظ…ط² ط¹ط¨ظˆط± ط§ط´طھط¨ط§ظ‡ ط§ط³طھ.');
      }

      final authResponse = await _supabase.auth.signInWithPassword(
        email: '$username@gymf.com', // ط§غŒظ…غŒظ„ ظپط±ط¶غŒ
        password: password,
      );

      _currentUser = userData;
      notifyListeners();
    } catch (e) {
      throw Exception('ط®ط·ط§ ط¯ط± ظˆط±ظˆط¯: $e');
    }
  }

  /// طھع©ظ…غŒظ„ ظ¾ط±ظˆظپط§غŒظ„ ط¨ط¹ط¯ ط§ط² ظˆط±ظˆط¯ ط¨ط§ ع¯ظˆع¯ظ„ غŒط§ OTP
  Future<void> completeProfile(String username, String role) async {
    try {
      if (!await isUsernameUnique(username)) {
        throw Exception('ط§غŒظ† غŒظˆط²ط±ظ†غŒظ… ظ‚ط¨ظ„ط§ظ‹ ط§ط³طھظپط§ط¯ظ‡ ط´ط¯ظ‡ ط§ط³طھ.');
      }

      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('ع©ط§ط±ط¨ط± ظ…ظ‚ط¯ط§ط±ط¯ظ‡غŒ ظ†ط´ط¯ظ‡ ط§ط³طھ.');
      }

      _currentUser ??= UserModel(
        userId: userId,
        phone: '',
        username: username,
        role: role,
        isVerified: true,
        createdAt: DateTime.now(),
        password: '',
      );

      _currentUser = _currentUser!.copyWith(username: username, role: role);
      await saveUserData(_currentUser!);

      notifyListeners();
    } catch (e) {
      throw Exception('ط®ط·ط§ ط¯ط± طھع©ظ…غŒظ„ ظ¾ط±ظˆظپط§غŒظ„: $e');
    }
  }

  /// ط¨ط±ط±ط³غŒ غŒع©طھط§ ط¨ظˆط¯ظ† غŒظˆط²ط±ظ†غŒظ…
  Future<bool> isUsernameUnique(String username) async {
    final response =
        await _supabase
            .from('users')
            .select()
            .eq('username', username)
            .maybeSingle();
    return response == null;
  }

  /// ط°ط®غŒط±ظ‡ ط§ط·ظ„ط§ط¹ط§طھ ع©ط§ط±ط¨ط± ط¯ط± ط¯غŒطھط§ط¨غŒط³
  Future<void> saveUserData(UserModel user) async {
    print("ًں“Œ Data before upsert: ${user.toMap()}");

    await _supabase.from('users').upsert(user.toMap());
  }

  /// ط¯ط±غŒط§ظپطھ ط§ط·ظ„ط§ط¹ط§طھ ع©ط§ط±ط¨ط± ط¨ط§ `userId`
  Future<UserModel?> getUserData(String userId) async {
    final response =
        await _supabase.from('users').select().eq('id', userId).maybeSingle();
    return response != null ? UserModel.fromMap(response) : null;
  }

  /// ط¯ط±غŒط§ظپطھ ط§ط·ظ„ط§ط¹ط§طھ ع©ط§ط±ط¨ط± ط¨ط§ `username`
  Future<UserModel?> getUserDataByUsername(String username) async {
    final response =
        await _supabase
            .from('users')
            .select()
            .eq('username', username)
            .maybeSingle();
    return response != null ? UserModel.fromMap(response) : null;
  }

  /// ظ„ط؛ظˆ `StreamSubscription` ط¨ط±ط§غŒ ط¬ظ„ظˆع¯غŒط±غŒ ط§ط² ط§ط¬ط±ط§غŒ ع†ظ†ط¯ط¨ط§ط±ظ‡
  Future<void> disposeAuthListener() async {
    await _authSubscription.cancel();
  }

  /// ظ…ظ†طھط¸ط± ظ…ط§ظ†ط¯ظ† ط¨ط±ط§غŒ طھع©ظ…غŒظ„ ظˆط±ظˆط¯
  Future<void> _waitForUser() async {
    int retries = 20;
    while (_supabase.auth.currentUser == null && retries > 0) {
      await Future.delayed(const Duration(milliseconds: 800));
      retries--;
    }
  }

  /// ط¯ط±غŒط§ظپطھ ط§ط·ظ„ط§ط¹ط§طھ ع©ط§ط±ط¨ط± ط¨ط§ ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„
  Future<UserModel?> getUserDataByPhone(String phone) async {
    final response =
        await _supabase.from('users').select().eq('phone', phone).maybeSingle();
    return response != null ? UserModel.fromMap(response) : null;
  }
}
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:gymf/data/models/exercise_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class ExerciseProvider with ChangeNotifier {
  // ظ…طھط؛غŒط±ظ‡ط§غŒ ط§ط³طھغŒطھ
  String? selectedCategory;
  String? selectedType;
  File? selectedImage;
  File? selectedVideo;
  bool isLoading = false;
  List<Map<String, dynamic>> _coachExercises = [];
  List<Map<String, dynamic>> get coachExercises => _coachExercises;

  final SupabaseClient _supabase = Supabase.instance.client;

  void setCategory(String category) {
    selectedCategory = category;
    notifyListeners();
  }

  void setType(String type) {
    selectedType = type;
    notifyListeners();
  }

  void setImage(File image) {
    selectedImage = image;
    notifyListeners();
  }

  void setVideo(File video) {
    selectedVideo = video;
    notifyListeners();
  }

  void resetForm() {
    selectedCategory = null;
    selectedType = null;
    selectedImage = null;
    selectedVideo = null;
    notifyListeners();
  }

  Future<String?> _uploadFile(File file, String path) async {
    try {
      await _supabase.storage.from('exercise_media').upload(path, file);
      return _supabase.storage.from('exercise_media').getPublicUrl(path);
    } catch (e) {
      debugPrint('ط®ط·ط§ ط¯ط± ط¢ظ¾ظ„ظˆط¯ ظپط§غŒظ„: $e');
      return null;
    }
  }

  Future<void> submitExercise({
    required String name,
    required String type,
    required String category,
    required String userRole,
    required String coachUsername,
    String? description,
    required VoidCallback onSuccess,
    required Function(String?)
    onFailure, // ط­ط§ظ„ط§ `onFailure` ظ…ظ‚ط¯ط§ط± ط®ط·ط§ ط±ط§ ظ…غŒâ€Œع¯غŒط±ط¯
  }) async {
    if (name.isEmpty || coachUsername.isEmpty) {
      onFailure('ظ„ط·ظپط§ظ‹ ظ‡ظ…ظ‡ ظپغŒظ„ط¯ظ‡ط§ ط±ط§ ظ¾ط± ع©ظ†غŒط¯');
      return;
    }

    if (userRole != 'coach') {
      onFailure('ظپظ‚ط· ظ…ط±ط¨غŒط§ظ† ظ…غŒâ€Œطھظˆط§ظ†ظ†ط¯ طھظ…ط±غŒظ† ط§ط¶ط§ظپظ‡ ع©ظ†ظ†ط¯!');
      return;
    }

    isLoading = true;
    notifyListeners();

    try {
      String? imageUrl;
      String? videoUrl;
      final exerciseId = DateTime.now().millisecondsSinceEpoch.toString();

      if (selectedImage != null) {
        imageUrl = await _uploadFile(
          selectedImage!,
          '$coachUsername/$exerciseId/image.jpg',
        );
      }

      if (selectedVideo != null) {
        videoUrl = await _uploadFile(
          selectedVideo!,
          '$coachUsername/$exerciseId/video.mp4',
        );
      }

      ExerciseModel exercise = ExerciseModel(
        category: category,
        type: type,
        name: name,
        coachUsername: coachUsername,
        description: description,
        imageUrl: imageUrl,
        videoUrl: videoUrl,
      );

      await _supabase.from('exercises').insert(exercise.toJson());

      onSuccess(); // ظ…ظˆظپظ‚غŒطھâ€Œط¢ظ…غŒط² ط¨ظˆط¯
      resetForm();
      await fetchCoachExercises(coachUsername);
    } catch (e) {
      debugPrint('ط®ط·ط§ ط¯ط± ط«ط¨طھ طھظ…ط±غŒظ†: $e');
      onFailure('ظ…ط´ع©ظ„غŒ ظ¾غŒط´ ط¢ظ…ط¯طŒ ط¯ظˆط¨ط§ط±ظ‡ ط§ظ…طھط­ط§ظ† ع©ظ†غŒط¯!');
    }

    isLoading = false;
    notifyListeners();
  }

  Future<void> deleteExercise(String exerciseId, String coachUsername) async {
    try {
      await _supabase.from('exercises').delete().eq('id', exerciseId);
      _coachExercises.removeWhere((exercise) => exercise['id'] == exerciseId);
      notifyListeners();
    } catch (error) {
      debugPrint("â‌Œ ط®ط·ط§ ط¯ط± ط­ط°ظپ طھظ…ط±غŒظ†: $error");
    }
  }

  Future<void> fetchCoachExercises(String coachUsername) async {
    try {
      final response = await _supabase
          .from('exercises')
          .select()
          .eq('coachUsername', coachUsername);
      if (response.isNotEmpty && response != _coachExercises) {
        _coachExercises = List<Map<String, dynamic>>.from(response);
        notifyListeners();
      }
    } catch (error) {
      debugPrint("â‌Œ ط®ط·ط§ ط¯ط± ط¯ط±غŒط§ظپطھ طھظ…ط±غŒظ†ط§طھ: $error");
    }
  }
}
import 'package:flutter/material.dart';
import 'package:gymf/providers/auth_provider.dart';
import 'package:gymf/ui/widgets/custom_button.dart';
import 'package:gymf/ui/widgets/custom_text_field.dart';
import 'package:provider/provider.dart';

class CompleteProfileScreen extends StatefulWidget {
  const CompleteProfileScreen({super.key});

  @override
  _CompleteProfileScreenState createState() => _CompleteProfileScreenState();
}

class _CompleteProfileScreenState extends State<CompleteProfileScreen> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _coachCodeController = TextEditingController();
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  String _selectedRole = 'athlete';
  bool _isLoading = false;

  @override
  void dispose() {
    _usernameController.dispose();
    _coachCodeController.dispose();
    super.dispose();
  }

  void _submitProfile() async {
    if (!_formKey.currentState!.validate()) return;
    FocusScope.of(context).unfocus(); // ط¨ط³طھظ† ع©غŒط¨ظˆط±ط¯

    setState(() => _isLoading = true);

    try {
      await Provider.of<AuthProvider>(
        context,
        listen: false,
      ).completeProfile(_usernameController.text.trim(), _selectedRole);

      if (mounted) {
        setState(() => _isLoading = false);
        Navigator.pushReplacementNamed(context, '/dashboard');
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        _showError('ط®ط·ط§ ط¯ط± ط«ط¨طھ ط§ط·ظ„ط§ط¹ط§طھ: ${e.toString()}');
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('طھع©ظ…غŒظ„ ظ¾ط±ظˆظپط§غŒظ„')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              CustomTextField(
                controller: _usernameController,
                label: 'غŒظˆط²ط±ظ†غŒظ…',
                validator:
                    (value) =>
                        value == null || value.trim().isEmpty
                            ? 'غŒظˆط²ط±ظ†غŒظ… ظ†ظ…غŒâ€Œطھظˆط§ظ†ط¯ ط®ط§ظ„غŒ ط¨ط§ط´ط¯!'
                            : null,
              ),
              const SizedBox(height: 20),
              DropdownButtonFormField<String>(
                value: _selectedRole,
                decoration: InputDecoration(
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                    borderSide: const BorderSide(color: Colors.grey),
                  ),
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 14,
                    vertical: 10,
                  ),
                ),
                items: const [
                  DropdownMenuItem(value: 'athlete', child: Text('ظˆط±ط²ط´ع©ط§ط±')),
                  DropdownMenuItem(value: 'coach', child: Text('ظ…ط±ط¨غŒ')),
                ],
                onChanged: (value) {
                  if (value == null) return;
                  setState(() {
                    _selectedRole = value;
                    _coachCodeController.clear();
                  });
                },
              ),
              const SizedBox(height: 20),
              if (_selectedRole == 'coach')
                CustomTextField(
                  controller: _coachCodeController,
                  label: 'ع©ط¯ طھط£غŒغŒط¯ ظ…ط±ط¨غŒ',
                  validator:
                      (value) =>
                          value == '18946704' ? null : 'ع©ط¯ طھط£غŒغŒط¯ ظ†ط§ط¯ط±ط³طھ ط§ط³طھ!',
                ),
              const SizedBox(height: 30),
              _isLoading
                  ? const CircularProgressIndicator()
                  : CustomButton(
                    text: 'ط«ط¨طھ ط§ط·ظ„ط§ط¹ط§طھ',
                    onPressed: _submitProfile,
                    backgroundColor: Colors.blueAccent,
                    textColor: Colors.white,
                    borderRadius: 12,
                    padding: const EdgeInsets.symmetric(vertical: 14),
                  ),
            ],
          ),
        ),
      ),
    );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        backgroundColor: Colors.redAccent.withOpacity(0.9),
        content: Row(
          children: [
            const Icon(Icons.error, color: Colors.white),
            const SizedBox(width: 10),
            Expanded(
              child: Text(
                message,
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ],
        ),
        duration: const Duration(seconds: 3),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../providers/auth_provider.dart';
import '../../widgets/custom_button.dart';
import '../../widgets/custom_text_field.dart';

class LoginScreen extends StatelessWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 40),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Image.asset('images/logo.png', height: 100),
              const SizedBox(height: 40),
              const Text(
                'ظˆط±ظˆط¯',
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                  color: Colors.yellowAccent,
                ),
              ),
              const SizedBox(height: 40),
              const _LoginForm(),
            ],
          ),
        ),
      ),
    );
  }
}

class _LoginForm extends StatefulWidget {
  const _LoginForm();

  @override
  _LoginFormState createState() => _LoginFormState();
}

class _LoginFormState extends State<_LoginForm> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();

  @override
  void dispose() {
    _usernameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        CustomTextField(controller: _usernameController, label: 'غŒظˆط²ط±ظ†غŒظ…'),
        const SizedBox(height: 20),
        CustomTextField(
          controller: _passwordController,
          label: 'ط±ظ…ط² ط¹ط¨ظˆط±',
          obscureText: true,
        ),
        const SizedBox(height: 30),
        CustomButton(
          text: 'ظˆط±ظˆط¯',
          onPressed: () async {
            await Provider.of<AuthProvider>(
              context,
              listen: false,
            ).signInWithUsername(
              _usernameController.text,
              _passwordController.text,
            );
          },
        ),
        const SizedBox(height: 15),
        CustomButton(
          text: 'ظˆط±ظˆط¯ ط¨ط§ ط¬غŒظ…غŒظ„',
          onPressed: () {
            Provider.of<AuthProvider>(
              context,
              listen: false,
            ).signInWithGoogle(context);
          },
        ),
        const SizedBox(height: 15),
        TextButton(
          onPressed: () {
            showModalBottomSheet(
              context: context,
              backgroundColor: Colors.transparent,
              isScrollControlled: true,
              builder: (context) => const SignUpSheet(),
            );
          },
          child: const Text(
            'ط«ط¨طھâ€Œظ†ط§ظ…',
            style: TextStyle(fontSize: 16, color: Colors.yellowAccent),
          ),
        ),
      ],
    );
  }
}

class SignUpSheet extends StatelessWidget {
  const SignUpSheet({super.key});

  @override
  Widget build(BuildContext context) {
    return DraggableScrollableSheet(
      initialChildSize: 0.7,
      maxChildSize: 0.9,
      minChildSize: 0.5,
      builder: (context, scrollController) {
        return Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            color: Colors.black,
            borderRadius: const BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: SingleChildScrollView(
            controller: scrollController,
            child: const _SignUpForm(),
          ),
        );
      },
    );
  }
}

class _SignUpForm extends StatefulWidget {
  const _SignUpForm();

  @override
  _SignUpFormState createState() => _SignUpFormState();
}

class _SignUpFormState extends State<_SignUpForm> {
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final TextEditingController _coachCodeController = TextEditingController();
  String _selectedRole = 'athlete';

  @override
  void dispose() {
    _phoneController.dispose();
    _usernameController.dispose();
    _passwordController.dispose();
    _coachCodeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Text(
          'ط«ط¨طھâ€Œظ†ط§ظ…',
          style: TextStyle(fontSize: 24, color: Colors.yellowAccent),
        ),
        const SizedBox(height: 20),
        CustomTextField(
          controller: _phoneController,
          label: 'ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„',
          keyboardType: TextInputType.phone,
        ),
        const SizedBox(height: 20),
        CustomTextField(controller: _usernameController, label: 'غŒظˆط²ط±ظ†غŒظ…'),
        const SizedBox(height: 20),
        CustomTextField(
          controller: _passwordController,
          label: 'ط±ظ…ط² ط¹ط¨ظˆط±',
          obscureText: true,
        ),
        const SizedBox(height: 20),
        DropdownButton<String>(
          value: _selectedRole,
          items: const [
            DropdownMenuItem(
              value: 'athlete',
              child: Text('ظˆط±ط²ط´ع©ط§ط±', style: TextStyle(color: Colors.white)),
            ),
            DropdownMenuItem(
              value: 'coach',
              child: Text('ظ…ط±ط¨غŒ', style: TextStyle(color: Colors.white)),
            ),
          ],
          onChanged: (value) => setState(() => _selectedRole = value!),
          dropdownColor: Colors.black,
          style: const TextStyle(color: Colors.white),
          iconEnabledColor: Colors.yellowAccent,
        ),
        if (_selectedRole == 'coach')
          CustomTextField(
            controller: _coachCodeController,
            label: 'ع©ط¯ طھط£غŒغŒط¯ ظ…ط±ط¨غŒ',
          ),
        const SizedBox(height: 20),
        CustomButton(
          text: 'ط§ط±ط³ط§ظ„ OTP',
          onPressed: () async {
            await Provider.of<AuthProvider>(
              context,
              listen: false,
            ).signUpWithPhone(
              _phoneController.text,
              _usernameController.text,
              _passwordController.text,
              _selectedRole,
            );
          },
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';
import 'package:gymf/core/services/otp_service.dart';
import 'package:gymf/ui/screens/auth/verify_otp_screen.dart';
import 'package:provider/provider.dart';
import '../../../providers/auth_provider.dart';
import '../../widgets/custom_button.dart';
import '../../widgets/custom_text_field.dart';
import 'complete_profile_screen.dart';

class SignupScreen extends StatefulWidget {
  const SignupScreen({super.key});

  @override
  _SignupScreenState createState() => _SignupScreenState();
}

class _SignupScreenState extends State<SignupScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _slideAnimation;
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final TextEditingController _coachCodeController = TextEditingController();
  String _selectedRole = 'athlete';

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );
    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 1),
      end: Offset.zero,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    _phoneController.dispose();
    _usernameController.dispose();
    _passwordController.dispose();
    _coachCodeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: SlideTransition(
          position: _slideAnimation,
          child: SingleChildScrollView(
            padding: const EdgeInsets.symmetric(
              horizontal: 24.0,
              vertical: 40.0,
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                _buildLogo(),
                const SizedBox(height: 40),
                _buildTitle(),
                const SizedBox(height: 60),
                CustomTextField(
                  controller: _phoneController,
                  label: 'ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„',
                  keyboardType: TextInputType.phone,
                ),
                const SizedBox(height: 30),
                CustomTextField(
                  controller: _usernameController,
                  label: 'غŒظˆط²ط±ظ†غŒظ…',
                ),
                const SizedBox(height: 30),
                CustomTextField(
                  controller: _passwordController,
                  label: 'ط±ظ…ط² ط¹ط¨ظˆط±',
                  obscureText: true,
                ),
                const SizedBox(height: 30),
                _buildRoleDropdown(),
                if (_selectedRole == 'coach') _buildCoachCodeField(),
                const SizedBox(height: 40),
                _buildOtpButton(authProvider),
                const SizedBox(height: 20),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildLogo() {
    return Image.asset(
      'assets/logo.png',
      height: 120,
      width: 120,
      color: Colors.yellowAccent,
    );
  }

  Widget _buildTitle() {
    return const Text(
      'ط«ط¨طھâ€Œظ†ط§ظ…',
      style: TextStyle(
        fontSize: 32,
        fontWeight: FontWeight.bold,
        color: Colors.yellowAccent,
      ),
    );
  }

  Widget _buildRoleDropdown() {
    return DropdownButton<String>(
      value: _selectedRole,
      items: const [
        DropdownMenuItem(
          value: 'athlete',
          child: Text('ظˆط±ط²ط´ع©ط§ط±', style: TextStyle(color: Colors.white)),
        ),
        DropdownMenuItem(
          value: 'coach',
          child: Text('ظ…ط±ط¨غŒ', style: TextStyle(color: Colors.white)),
        ),
      ],
      onChanged: (value) => setState(() => _selectedRole = value!),
      dropdownColor: Colors.black,
      style: const TextStyle(color: Colors.white),
      iconEnabledColor: Colors.yellowAccent,
    );
  }

  Widget _buildCoachCodeField() {
    return Column(
      children: [
        const SizedBox(height: 30),
        CustomTextField(
          controller: _coachCodeController,
          label: 'ع©ط¯ طھط£غŒغŒط¯ ظ…ط±ط¨غŒ',
        ),
      ],
    );
  }

  Widget _buildOtpButton(AuthProvider authProvider) {
    return CustomButton(
      text: 'ط§ط±ط³ط§ظ„ OTP',
      onPressed: () async {
        if (!OtpService().isValidIranianPhoneNumber(_phoneController.text)) {
          _showSnackbar(
            'ط´ظ…ط§ط±ظ‡ ظ…ظˆط¨ط§غŒظ„ ظ†ط§ظ…ط¹طھط¨ط± ط§ط³طھ. ظ„ط·ظپط§ظ‹ ط´ظ…ط§ط±ظ‡â€Œط§غŒ ط¨ط§ ظپط±ظ…طھ 09XXXXXXXXX ظˆط§ط±ط¯ ع©ظ†غŒط¯.',
          );
          return;
        }
        if (_selectedRole == 'coach' && _coachCodeController.text.isEmpty) {
          _showSnackbar('ع©ط¯ طھط£غŒغŒط¯ ظ…ط±ط¨غŒ ط§ظ„ط²ط§ظ…غŒ ط§ط³طھ.');
          return;
        }
        try {
          await authProvider.signUpWithPhone(
            _phoneController.text,
            _usernameController.text,
            _passwordController.text,
            _selectedRole,
          );
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (_) => VerifyOtpScreen(phone: _phoneController.text),
            ),
          );
        } catch (e) {
          _showSnackbar('ط®ط·ط§: ${e.toString()}');
        }
      },
    );
  }

  void _showSnackbar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        backgroundColor: Colors.black,
        content: Text(
          message,
          style: const TextStyle(color: Colors.yellowAccent),
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:gymf/core/services/otp_service.dart';
import 'package:provider/provider.dart';
import '../../../providers/auth_provider.dart';
import '../../widgets/custom_text_field.dart';
import '../../widgets/custom_button.dart';
import '../home_screen.dart';
import 'dart:async';

class VerifyOtpScreen extends StatefulWidget {
  final String phone;

  const VerifyOtpScreen({super.key, required this.phone});

  @override
  _VerifyOtpScreenState createState() => _VerifyOtpScreenState();
}

class _VerifyOtpScreenState extends State<VerifyOtpScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<Offset> _slideAnimation;
  final TextEditingController _otpController = TextEditingController();
  Timer? _resendTimer;
  int _secondsRemaining = 30;
  bool _canResend = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );
    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 1),
      end: Offset.zero,
    ).animate(CurvedAnimation(parent: _controller, curve: Curves.easeInOut));
    _controller.forward();
    _startResendTimer();
  }

  void _startResendTimer() {
    setState(() {
      _canResend = false;
      _secondsRemaining = 30;
    });
    _resendTimer?.cancel();
    _resendTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_secondsRemaining > 0) {
        setState(() {
          _secondsRemaining--;
        });
      } else {
        timer.cancel();
        setState(() {
          _canResend = true;
        });
      }
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    _otpController.dispose();
    _resendTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        backgroundColor: Colors.black,
        title: const Text(
          'طھط£غŒغŒط¯ OTP',
          style: TextStyle(color: Colors.yellowAccent),
        ),
      ),
      body: SafeArea(
        child: SlideTransition(
          position: _slideAnimation,
          child: SingleChildScrollView(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const SizedBox(height: 40),
                  const Text(
                    'ع©ط¯ طھط£غŒغŒط¯ ط±ط§ ظˆط§ط±ط¯ ع©ظ†غŒط¯',
                    style: TextStyle(
                      fontSize: 24,
                      color: Colors.yellowAccent,
                      shadows: [Shadow(color: Colors.black, blurRadius: 8)],
                    ),
                  ),
                  const SizedBox(height: 60),
                  CustomTextField(
                    controller: _otpController,
                    label: 'ع©ط¯ OTP',
                    keyboardType: TextInputType.number,
                  ),
                  const SizedBox(height: 40),
                  CustomButton(
                    text: 'طھط£غŒغŒط¯',
                    onPressed: () async {
                      try {
                        final authProvider = Provider.of<AuthProvider>(
                          context,
                          listen: false,
                        );
                        await authProvider.verifyOtp(
                          widget.phone,
                          _otpController.text,
                        );
                        Navigator.pushReplacement(
                          context,
                          MaterialPageRoute(builder: (_) => const HomeScreen()),
                        );
                      } catch (e) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          SnackBar(
                            backgroundColor: Colors.black,
                            content: Text(
                              _getErrorMessage(e.toString()),
                              style: const TextStyle(
                                color: Colors.yellowAccent,
                              ),
                            ),
                          ),
                        );
                      }
                    },
                  ),
                  const SizedBox(height: 20),
                  TextButton(
                    onPressed:
                        _canResend
                            ? () async {
                              try {
                                final otpService = OtpService();
                                await otpService.sendOtp(widget.phone);
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    backgroundColor: Colors.black,
                                    content: Text(
                                      'OTP ط¯ظˆط¨ط§ط±ظ‡ ط§ط±ط³ط§ظ„ ط´ط¯',
                                      style: TextStyle(
                                        color: Colors.yellowAccent,
                                      ),
                                    ),
                                  ),
                                );
                                _startResendTimer();
                              } catch (e) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    backgroundColor: Colors.black,
                                    content: Text(
                                      _getErrorMessage(e.toString()),
                                      style: const TextStyle(
                                        color: Colors.yellowAccent,
                                      ),
                                    ),
                                  ),
                                );
                              }
                            }
                            : null,
                    child: Text(
                      _canResend
                          ? 'ط§ط±ط³ط§ظ„ ظ…ط¬ط¯ط¯ OTP'
                          : 'ط§ط±ط³ط§ظ„ ظ…ط¬ط¯ط¯ ط¯ط± $_secondsRemaining ط«ط§ظ†غŒظ‡',
                      style: TextStyle(
                        color: Colors.yellowAccent,
                        fontSize: 16,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  String _getErrorMessage(String error) {
    switch (error) {
      case 'ع©ط¯ OTP ظ†ط§ظ…ط¹طھط¨ط± ط§ط³طھ.':
        return 'ع©ط¯غŒ ع©ظ‡ ظˆط§ط±ط¯ ع©ط±ط¯غŒط¯ ط§ط´طھط¨ط§ظ‡ ط§ط³طھ. ظ„ط·ظپط§ظ‹ ط¯ظˆط¨ط§ط±ظ‡ ط§ظ…طھط­ط§ظ† ع©ظ†غŒط¯.';
      default:
        return 'ط®ط·ط§غŒ ظ†ط§ط´ظ†ط§ط®طھظ‡: $error';
    }
  }
}
import 'package:flutter/material.dart';

class CoachesScreen extends StatelessWidget {
  const CoachesScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(child: Text("ظ…ط±ط¨غŒط§ظ†"));
  }
}
import 'package:flutter/material.dart';

class CoachListScreen extends StatelessWidget {
  final List<Map<String, dynamic>> coaches = [
    {
      'name': 'ظ…ط­ظ…ط¯ ط±ط¶ط§غŒغŒ',
      'experience': 'غµ ط³ط§ظ„ ط³ط§ط¨ظ‚ظ‡',
      'clients': 120,
      'achievements': 10,
      'image': 'https://via.placeholder.com/150',
    },
    {
      'name': 'ط¹ظ„غŒ ع©ط±غŒظ…غŒ',
      'experience': 'غ· ط³ط§ظ„ ط³ط§ط¨ظ‚ظ‡',
      'clients': 200,
      'achievements': 15,
      'image': 'https://via.placeholder.com/150',
    },
    {
      'name': 'ط²ظ‡ط±ط§ ط§ط­ظ…ط¯غŒ',
      'experience': 'غ³ ط³ط§ظ„ ط³ط§ط¨ظ‚ظ‡',
      'clients': 90,
      'achievements': 5,
      'image': 'https://via.placeholder.com/150',
    },
  ];

  CoachListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('ظ„غŒط³طھ ظ…ط±ط¨غŒط§ظ†'), centerTitle: true),
      body: ListView.builder(
        itemCount: coaches.length,
        itemBuilder: (context, index) {
          final coach = coaches[index];
          return Card(
            margin: EdgeInsets.symmetric(vertical: 8, horizontal: 16),
            child: ListTile(
              leading: CircleAvatar(
                backgroundImage: NetworkImage(coach['image']),
              ),
              title: Text(
                coach['name'],
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              subtitle: Text(
                '${coach['experience']} | ${coach['clients']} ط´ط§ع¯ط±ط¯ | ${coach['achievements']} ظ…ظ‚ط§ظ…',
              ),
              trailing: Icon(Icons.arrow_forward_ios),
              onTap: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => CoachDetailScreen(coach: coach),
                  ),
                );
              },
            ),
          );
        },
      ),
    );
  }
}

class CoachDetailScreen extends StatelessWidget {
  final Map<String, dynamic> coach;

  const CoachDetailScreen({super.key, required this.coach});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(coach['name'])),
      body: Padding(
        padding: EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            CircleAvatar(
              radius: 50,
              backgroundImage: NetworkImage(coach['image']),
            ),
            SizedBox(height: 16),
            Text(
              coach['name'],
              style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(coach['experience'], style: TextStyle(fontSize: 16)),
            SizedBox(height: 8),
            Text(
              '${coach['clients']} ط´ط§ع¯ط±ط¯ | ${coach['achievements']} ظ…ظ‚ط§ظ…',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
            SizedBox(height: 16),
            ElevatedButton(onPressed: () {}, child: Text('ط¯ط±ط®ظˆط§ط³طھ ظ…ط´ط§ظˆط±ظ‡')),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:gymf/ui/screens/coaches_screen.dart';
import 'package:gymf/ui/screens/exercise_submission_screen.dart';
import 'package:gymf/ui/screens/home_screen.dart';
import 'package:gymf/ui/screens/profile_screen.dart';
import 'package:gymf/ui/screens/workout_plan_screen.dart';

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({super.key});

  @override
  _DashboardScreenState createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen> {
  int _currentIndex = 0;
  final List<Widget> _screens = [
    HomeScreen(),
    CoachesScreen(),
    ProfileScreen(),
  ];

  void _onTabTapped(int index) {
    setState(() {
      _currentIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("ط¯ط§ط´ط¨ظˆط±ط¯")),
      drawer: Drawer(
        child: ListView(
          padding: EdgeInsets.zero,
          children: <Widget>[
            DrawerHeader(
              decoration: BoxDecoration(color: Colors.blue),
              child: Text(
                'ظ…ظ†ظˆغŒ ع©ط§ط±ط¨ط±غŒ',
                style: TextStyle(color: Colors.white, fontSize: 24),
              ),
            ),
            ListTile(
              leading: Icon(Icons.person),
              title: Text("ظ¾ط±ظˆظپط§غŒظ„"),
              onTap: () {
                Navigator.pop(context);
                _onTabTapped(2);
              },
            ),
            ListTile(
              leading: Icon(Icons.fitness_center),
              title: Text("ط«ط¨طھ طھظ…ط±غŒظ†"),
              onTap: () {
                Navigator.pop(context);
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder:
                        (context) =>
                            ExerciseSubmissionScreen(), // طµظپط­ظ‡ ط«ط¨طھ طھظ…ط±غŒظ†
                  ),
                );
              },
            ),
            ListTile(
              leading: Icon(Icons.fitness_center),
              title: Text("ط«ط¨طھ طھظ…ط±غŒظ†"),
              onTap: () {
                Navigator.pop(context);
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => WorkoutPlanScreen(), // طµظپط­ظ‡ ط«ط¨طھ طھظ…ط±غŒظ†
                  ),
                );
              },
            ),
            ListTile(
              leading: Icon(Icons.logout),
              title: Text("ط®ط±ظˆط¬ ط§ط² ط­ط³ط§ط¨"),
              onTap: () {
                print("ط®ط±ظˆط¬ ط§ط² ط­ط³ط§ط¨");
              },
            ),
          ],
        ),
      ),

      body: IndexedStack(index: _currentIndex, children: _screens),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: _onTabTapped,
        items: [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: "ط®ط§ظ†ظ‡"),
          BottomNavigationBarItem(
            icon: Icon(Icons.fitness_center),
            label: "ظ…ط±ط¨غŒط§ظ†",
          ),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: "ظ¾ط±ظˆظپط§غŒظ„"),
        ],
      ),
    );
  }
}
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:gymf/data/models/exercise_model.dart';
import 'package:gymf/providers/exercise_provider.dart';
import 'package:provider/provider.dart';
import 'package:image_picker/image_picker.dart';

class ExerciseSubmissionScreen extends StatefulWidget {
  const ExerciseSubmissionScreen({super.key});

  @override
  State<ExerciseSubmissionScreen> createState() =>
      _ExerciseSubmissionScreenState();
}

class _ExerciseSubmissionScreenState extends State<ExerciseSubmissionScreen> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _descriptionController = TextEditingController();

  String? selectedCategory;
  String? selectedMuscleGroup;
  String? selectedExercise;
  File? selectedImage;
  File? selectedVideo;

  final Map<String, List<String>> muscleGroups = {
    'ظ‚ط¯ط±طھغŒ': ['ط³غŒظ†ظ‡', 'ط¨ط§ط²ظˆ', 'ظ¾ط§'],
    'ط§ط³طھظ‚ط§ظ…طھغŒ': ['ط§طµظ„غŒ'],
    'ظ‡ظˆط§ط²غŒ': ['ط§طµظ„غŒ'],
  };

  final Map<String, List<String>> exercises = {
    'ط³غŒظ†ظ‡': ['ظ¾ط±ط³ ط³غŒظ†ظ‡', 'ظ‚ظپط³ظ‡ ط³غŒظ†ظ‡'],
    'ط¨ط§ط²ظˆ': ['ط¬ظ„ظˆ ط¨ط§ط²ظˆ ط¯ظ…ط¨ظ„', 'ظ¾ط´طھ ط¨ط§ط²ظˆ ط³غŒظ…ع©ط´'],
    'ظ¾ط§': ['ط§ط³ع©ط§طھ', 'ظ„ط§ظ†ع¯ط²'],
    'ط§طµظ„غŒ': ['ط·ظ†ط§ط¨ ط²ط¯ظ†', 'ط¨ط§ط±ظپغŒع©ط³'],
  };

  Future<void> _pickMedia(ImageSource source, {bool isVideo = false}) async {
    final picker = ImagePicker();
    final pickedFile =
        await (isVideo
            ? picker.pickVideo(source: source)
            : picker.pickImage(source: source));
    if (pickedFile != null) {
      setState(() {
        isVideo
            ? selectedVideo = File(pickedFile.path)
            : selectedImage = File(pickedFile.path);
      });
    }
  }

  void _submitExercise(BuildContext context) {
    if (_nameController.text.isEmpty ||
        selectedCategory == null ||
        selectedMuscleGroup == null ||
        selectedExercise == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('ظ„ط·ظپط§ظ‹ ظ‡ظ…ظ‡ ظپغŒظ„ط¯ظ‡ط§ ط±ط§ ظ¾ط± ع©ظ†غŒط¯!')),
      );
      return;
    }

    Provider.of<ExerciseProvider>(context, listen: false).submitExercise(
      name: _nameController.text,
      type: selectedExercise!,
      category: selectedCategory!,
      userRole: 'coach',
      coachUsername: 'test_coach',
      description: _descriptionController.text,
      onSuccess:
          () => ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('طھظ…ط±غŒظ† ط¨ط§ ظ…ظˆظپظ‚غŒطھ ط«ط¨طھ ط´ط¯!')),
          ),
      onFailure:
          (error) => ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text('ط®ط·ط§ ط¯ط± ط«ط¨طھ طھظ…ط±غŒظ† â‌Œ: $error'))),
    );
  }

  @override
  Widget build(BuildContext context) {
    final provider = Provider.of<ExerciseProvider>(context);
    return Scaffold(
      appBar: AppBar(title: const Text('ط«ط¨طھ طھظ…ط±غŒظ†')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildDropdown(
                'ط¯ط³طھظ‡â€Œط¨ظ†ط¯غŒ',
                selectedCategory,
                muscleGroups.keys.toList(),
                (val) {
                  setState(() {
                    selectedCategory = val;
                    selectedMuscleGroup = null;
                    selectedExercise = null;
                  });
                },
              ),
              if (selectedCategory != null)
                _buildDropdown(
                  'ط¹ط¶ظ„ظ‡ ظ‡ط¯ظپ',
                  selectedMuscleGroup,
                  muscleGroups[selectedCategory]!,
                  (val) {
                    setState(() {
                      selectedMuscleGroup = val;
                      selectedExercise = null;
                    });
                  },
                ),
              if (selectedMuscleGroup != null)
                _buildDropdown(
                  'ط­ط±ع©طھ',
                  selectedExercise,
                  exercises[selectedMuscleGroup]!,
                  (val) {
                    setState(() => selectedExercise = val);
                  },
                ),
              _buildTextField(_nameController, 'ظ†ط§ظ… طھظ…ط±غŒظ†'),
              _buildTextField(
                _descriptionController,
                'طھظˆط¶غŒط­ط§طھ (ط§ط®طھغŒط§ط±غŒ)',
                maxLines: 3,
              ),
              const SizedBox(height: 10),
              _buildMediaPicker(),
              const SizedBox(height: 10),
              ElevatedButton(
                onPressed: () => _submitExercise(context),
                child: const Text('ط«ط¨طھ طھظ…ط±غŒظ†'),
              ),
              const SizedBox(height: 20),
              _buildExerciseList(provider),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDropdown(
    String label,
    String? value,
    List<String> items,
    ValueChanged<String?> onChanged,
  ) {
    return DropdownButtonFormField<String>(
      value: value,
      decoration: InputDecoration(labelText: label),
      items:
          items.map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
      onChanged: onChanged,
    );
  }

  Widget _buildTextField(
    TextEditingController controller,
    String label, {
    int maxLines = 1,
  }) {
    return TextField(
      controller: controller,
      decoration: InputDecoration(labelText: label),
      maxLines: maxLines,
    );
  }

  Widget _buildMediaPicker() {
    return Row(
      children: [
        if (selectedImage != null)
          Image.file(selectedImage!, width: 50, height: 50),
        IconButton(
          icon: const Icon(Icons.image),
          onPressed: () => _pickMedia(ImageSource.gallery),
        ),
        if (selectedVideo != null)
          const Icon(Icons.video_camera_back, size: 50),
        IconButton(
          icon: const Icon(Icons.videocam),
          onPressed: () => _pickMedia(ImageSource.camera, isVideo: true),
        ),
      ],
    );
  }

  Widget _buildExerciseList(ExerciseProvider provider) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('طھظ…ط±غŒظ†ط§طھ ط´ظ…ط§:', style: TextStyle(fontSize: 18)),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: provider.coachExercises.length,
          itemBuilder: (context, index) {
            final exercise = provider.coachExercises[index];
            return ListTile(
              title: Text(exercise['name']),
              subtitle: Text(exercise['category']),
              trailing: IconButton(
                icon: const Icon(Icons.edit),
                onPressed: () {},
              ),
            );
          },
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ط®ظˆط´ ط¢ظ…ط¯غŒطŒ ط³ظ„ط·ط§ظ†!')),
      body: const Center(child: Text('ط§غŒظ†ط¬ط§ طµظپط­ظ‡ ط§طµظ„غŒظ‡!')),
    );
  }
}
import 'package:flutter/material.dart';

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(child: Text("ظ¾ط±ظˆظپط§غŒظ„"));
  }
}
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class WorkoutPlanScreen extends StatefulWidget {
  const WorkoutPlanScreen({super.key});

  @override
  _WorkoutPlanScreenState createState() => _WorkoutPlanScreenState();
}

class _WorkoutPlanScreenState extends State<WorkoutPlanScreen> {
  String? selectedDay;
  TextEditingController planNameController = TextEditingController();
  List<Map<String, dynamic>> selectedExercises = [];

  List<String> days = [
    'ط±ظˆط² غ±',
    'ط±ظˆط² غ²',
    'ط±ظˆط² غ³',
    'ط±ظˆط² غ´',
    'ط±ظˆط² غµ',
    'ط±ظˆط² غ¶',
    'ط±ظˆط² غ·',
  ];
  List<Map<String, dynamic>> allExercises = [];

  @override
  void initState() {
    super.initState();
    _fetchExercises();
  }

  Future<void> _fetchExercises() async {
    final response = await Supabase.instance.client
        .from('exercises')
        .select('id, name, category, type');
    setState(() {
      allExercises = List<Map<String, dynamic>>.from(response);
    });
  }

  void _addExercise() {
    setState(() {
      selectedExercises.add({
        'exercise': null,
        'sets': '',
        'reps': '',
        'duration': '',
      });
    });
  }

  void _removeExercise(int index) {
    setState(() {
      selectedExercises.removeAt(index);
    });
  }

  Future<void> _saveWorkoutPlan() async {
    if (selectedDay == null ||
        planNameController.text.isEmpty ||
        selectedExercises.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('ظ„ط·ظپط§ظ‹ ظ‡ظ…ظ‡ ظپغŒظ„ط¯ظ‡ط§ ط±ط§ ظ¾ط± ع©ظ†غŒط¯')));
      return;
    }

    final userId = Supabase.instance.client.auth.currentUser?.id;
    if (userId == null) return;

    await Supabase.instance.client.from('workout_plans').insert({
      'user_id': userId,
      'day': selectedDay,
      'plan_name': planNameController.text,
      'exercises': selectedExercises,
    });

    ScaffoldMessenger.of(
      context,
    ).showSnackBar(SnackBar(content: Text('ط¨ط±ظ†ط§ظ…ظ‡ ط°ط®غŒط±ظ‡ ط´ط¯')));

    setState(() {
      selectedDay = null;
      planNameController.clear();
      selectedExercises.clear();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('ط¨ط±ظ†ط§ظ…ظ‡â€ŒغŒ طھظ…ط±غŒظ†غŒ')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            DropdownButtonFormField<String>(
              value: selectedDay,
              hint: Text('ط§ظ†طھط®ط§ط¨ ط±ظˆط²'),
              items:
                  days.map((day) {
                    return DropdownMenuItem(value: day, child: Text(day));
                  }).toList(),
              onChanged: (value) {
                setState(() {
                  selectedDay = value;
                });
              },
            ),
            SizedBox(height: 16),
            TextField(
              controller: planNameController,
              decoration: InputDecoration(labelText: 'ظ†ط§ظ… ط¨ط±ظ†ط§ظ…ظ‡'),
            ),
            SizedBox(height: 16),
            Text(
              'طھظ…ط±غŒظ†ط§طھ',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            ElevatedButton(
              onPressed: _addExercise,
              child: Text('ط§ظپط²ظˆط¯ظ† طھظ…ط±غŒظ†'),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: selectedExercises.length,
                itemBuilder: (context, index) {
                  return ListTile(
                    title: Text('طھظ…ط±غŒظ† ${index + 1}'),
                    trailing: IconButton(
                      icon: Icon(Icons.delete, color: Colors.red),
                      onPressed: () => _removeExercise(index),
                    ),
                  );
                },
              ),
            ),
            SizedBox(height: 16),
            ElevatedButton(
              onPressed: _saveWorkoutPlan,
              child: Text('ط°ط®غŒط±ظ‡ ط¨ط±ظ†ط§ظ…ظ‡'),
            ),
          ],
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';

class CustomButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final IconData? icon;
  final bool isLoading;
  final Color backgroundColor;
  final Color textColor;
  final double borderRadius;
  final EdgeInsetsGeometry padding;

  const CustomButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.icon,
    this.isLoading = false,
    this.backgroundColor = Colors.blueAccent,
    this.textColor = Colors.white,
    this.borderRadius = 12.0,
    this.padding = const EdgeInsets.symmetric(vertical: 14, horizontal: 20),
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      duration: const Duration(milliseconds: 200),
      opacity: isLoading ? 0.6 : 1.0, // ط²ظ…ط§ظ†غŒ ع©ظ‡ ط¯ع©ظ…ظ‡ ظ„ظˆط¯ ظ…غŒâ€Œط´ظˆط¯ ع©ظ…غŒ ظ…ط­ظˆ ط´ظˆط¯
      child: ElevatedButton(
        onPressed: isLoading ? null : onPressed,
        style: ElevatedButton.styleFrom(
          padding: padding,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(borderRadius),
          ),
          backgroundColor: backgroundColor,
          foregroundColor: textColor,
          elevation: 6,
        ),
        child:
            isLoading
                ? const SizedBox(
                  height: 24,
                  width: 24,
                  child: CircularProgressIndicator(
                    color: Colors.white,
                    strokeWidth: 2.0,
                  ),
                )
                : Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (icon != null) ...[
                      Icon(icon, size: 20, color: textColor),
                      const SizedBox(width: 8),
                    ],
                    Text(
                      text,
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: textColor,
                      ),
                    ),
                  ],
                ),
      ),
    );
  }
}
import 'package:flutter/material.dart';

class CustomTextField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String? hintText;
  final TextInputType keyboardType;
  final bool obscureText;
  final IconData? icon;
  final String? Function(String?)? validator; // ط§ط¶ط§ظپظ‡ ط´ط¯ âœ…

  const CustomTextField({
    super.key,
    required this.controller,
    this.label = '',
    this.hintText,
    this.keyboardType = TextInputType.text,
    this.obscureText = false,
    this.icon,
    this.validator, // ظ…ظ‚ط¯ط§ط± ظ¾غŒط´â€Œظپط±ط¶ null
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      keyboardType: keyboardType,
      obscureText: obscureText,
      style: const TextStyle(color: Colors.white),
      validator: validator, // ط§ط¶ط§ظپظ‡ ط´ط¯ âœ…
      decoration: InputDecoration(
        labelText: label,
        hintText: hintText,
        hintStyle: const TextStyle(color: Colors.white70),
        labelStyle: const TextStyle(color: Colors.amber),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(15),
          borderSide: const BorderSide(color: Colors.amber),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(15),
          borderSide: const BorderSide(color: Colors.amber, width: 2),
        ),
        filled: true,
        fillColor: Colors.black.withOpacity(0.3),
        prefixIcon: icon != null ? Icon(icon, color: Colors.amber) : null,
        contentPadding: const EdgeInsets.symmetric(
          vertical: 16,
          horizontal: 20,
        ),
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:gymf/providers/auth_provider.dart';
import 'package:gymf/providers/exercise_provider.dart';
import 'package:gymf/ui/screens/dashboard_screen.dart';
import 'package:gymf/ui/screens/home_screen.dart';
import 'package:provider/provider.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'ui/screens/auth/login_screen.dart';
import 'ui/screens/auth/signup_screen.dart';
import 'ui/screens/auth/complete_profile_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Supabase.initialize(
    url: 'https://fxikasjkeaymhlfqsxgc.supabase.co',
    anonKey:
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ4aWthc2prZWF5bWhsZnFzeGdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDAyOTA5NzAsImV4cCI6MjA1NTg2Njk3MH0.jhMtEI-aV3EkzTePTcsTSOaW6C6KlAt8kIxNBCpLY4o',
  );

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => AuthProvider()),
        ChangeNotifierProvider(create: (context) => ExerciseProvider()),
      ],
      child: MaterialApp(
        debugShowCheckedModeBanner: false,
        title: 'Gym App',
        theme: ThemeData.dark(),
        home: const AuthWrapper(),
        routes: {
          '/login': (context) => const LoginScreen(),
          '/signup': (context) => const SignupScreen(),
          '/complete-profile': (context) => const CompleteProfileScreen(),
          '/dashboard': (context) => DashboardScreen(),
          '/home': (context) => HomeScreen(),
        },
      ),
    );
  }
}

class AuthWrapper extends StatelessWidget {
  const AuthWrapper({super.key});

  @override
  Widget build(BuildContext context) {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    return FutureBuilder<bool>(
      future: authProvider.checkAuthStatus(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(child: CircularProgressIndicator()),
          );
        } else if (snapshot.data == true) {
          return DashboardScreen();
        } else {
          return const LoginScreen();
        }
      },
    );
  }
}
import 'dart:async';

import 'package:app_links_platform_interface/app_links_platform_interface.dart';
import 'package:gtk/gtk.dart';

class AppLinksPluginLinux extends AppLinksPlatform {
  static void registerWith() {
    AppLinksPlatform.instance = AppLinksPluginLinux();
  }

  StreamController<String>? _controller;
  GtkApplicationNotifier? _notifier;
  String? _initialLink;
  bool _initialLinkSent = false;
  String? _latestLink;

  // Initialize the plugin.
  // This can't be done in the constructor because
  // binary messenger hasn't been initialized at this stage.
  void _init() {
    _controller ??= StreamController.broadcast()..onListen = _onListen;

    if (_notifier == null) {
      _notifier = GtkApplicationNotifier();
      _notifier?.addCommandLineListener((args) {
        if (args.isNotEmpty) {
          _send(args.first);
        }
      });
    }
  }

  @override
  Future<Uri?> getInitialLink() async {
    _init();

    if (_initialLink case final link?) {
      return Uri.tryParse(link);
    }
    return null;
  }

  @override
  Future<String?> getInitialLinkString() async {
    _init();

    return _initialLink;
  }

  @override
  Future<Uri?> getLatestLink() async {
    _init();

    if (_latestLink case final link?) {
      return Uri.tryParse(link);
    }
    return null;
  }

  @override
  Future<String?> getLatestLinkString() async {
    _init();
    return _latestLink;
  }

  @override
  Stream<String> get stringLinkStream {
    _init();
    return _controller!.stream;
  }

  @override
  Stream<Uri> get uriLinkStream {
    _init();

    return _controller!.stream
        .where((uri) => Uri.tryParse(uri) != null)
        .map(Uri.parse);
  }

  void _onListen() {
    if (!_initialLinkSent && _initialLink != null) {
      _initialLinkSent = true;
      _controller?.add(_initialLink!);
    }
  }

  void _send(String uri) {
    if (uri.isNotEmpty) {
      _latestLink = uri;
      _initialLink ??= uri;

      if (_controller?.hasListener ?? false) {
        _initialLinkSent = true;
        _controller?.add(uri);
      }
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String> directoryPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoryPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoriesPaths, {super.key});

  /// The path selected in the dialog.
  final String directoriesPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoriesPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    const String fileMimeType = 'text/plain';
    final XFile textFile =
        XFile.fromData(fileData, mimeType: fileMimeType, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType {
  open,
  chooseDirectory,
  save,
}

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  String label;

  List<String> extensions;

  List<String> mimeTypes;

  Object encode() {
    return <Object?>[
      label,
      extensions,
      mimeTypes,
    ];
  }

  static PlatformTypeGroup decode(Object result) {
    result as List<Object?>;
    return PlatformTypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
      mimeTypes: (result[2] as List<Object?>?)!.cast<String>(),
    );
  }
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    this.allowedFileTypes,
    this.currentFolderPath,
    this.currentName,
    this.acceptButtonLabel,
    this.selectMultiple,
  });

  List<PlatformTypeGroup>? allowedFileTypes;

  String? currentFolderPath;

  String? currentName;

  String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  bool? selectMultiple;

  Object encode() {
    return <Object?>[
      allowedFileTypes,
      currentFolderPath,
      currentName,
      acceptButtonLabel,
      selectMultiple,
    ];
  }

  static PlatformFileChooserOptions decode(Object result) {
    result as List<Object?>;
    return PlatformFileChooserOptions(
      allowedFileTypes:
          (result[0] as List<Object?>?)?.cast<PlatformTypeGroup>(),
      currentFolderPath: result[1] as String?,
      currentName: result[2] as String?,
      acceptButtonLabel: result[3] as String?,
      selectMultiple: result[4] as bool?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is PlatformFileChooserActionType) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is PlatformTypeGroup) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PlatformFileChooserOptions) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null
            ? null
            : PlatformFileChooserActionType.values[value];
      case 130:
        return PlatformTypeGroup.decode(readValue(buffer)!);
      case 131:
        return PlatformFileChooserOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_linux.FileSelectorApi.showFileChooser$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[type, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!.cast<String>();
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Linux.
class FileSelectorLinux extends FileSelectorPlatform {
  /// Creates a new plugin implementation instance.
  FileSelectorLinux({
    @visibleForTesting FileSelectorApi? api,
  }) : _hostApi = api ?? FileSelectorApi();

  final FileSelectorApi _hostApi;

  /// Registers the Linux implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorLinux();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : XFile(paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.open,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
    return paths.map((String path) => XFile(path)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    // TODO(stuartmorgan): Add the selected type group here and return it. See
    // https://github.com/flutter/flutter/issues/107093
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.save,
        PlatformFileChooserOptions(
          allowedFileTypes:
              _platformTypeGroupsFromXTypeGroups(acceptedTypeGroups),
          currentFolderPath: options.initialDirectory,
          currentName: options.suggestedName,
          acceptButtonLabel: options.confirmButtonText,
        ));
    return paths.isEmpty ? null : FileSaveLocation(paths.first);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final List<String> paths = await _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: false,
        ));
    return paths.isEmpty ? null : paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    return _hostApi.showFileChooser(
        PlatformFileChooserActionType.chooseDirectory,
        PlatformFileChooserOptions(
          currentFolderPath: initialDirectory,
          acceptButtonLabel: confirmButtonText,
          selectMultiple: true,
        ));
  }
}

List<PlatformTypeGroup>? _platformTypeGroupsFromXTypeGroups(
    List<XTypeGroup>? groups) {
  return groups?.map(_platformTypeGroupFromXTypeGroup).toList();
}

PlatformTypeGroup _platformTypeGroupFromXTypeGroup(XTypeGroup group) {
  final String label = group.label ?? '';
  if (group.allowsAny) {
    return PlatformTypeGroup(
      label: label,
      extensions: <String>['*'],
    );
  }
  if ((group.extensions?.isEmpty ?? true) &&
      (group.mimeTypes?.isEmpty ?? true)) {
    throw ArgumentError('Provided type group $group does not allow '
        'all files, but does not set any of the Linux-supported filter '
        'categories. "extensions" or "mimeTypes" must be non-empty for Linux '
        'if anything is non-empty.');
  }
  return PlatformTypeGroup(
      label: label,
      // Covert to GtkFileFilter's *.<extension> format.
      extensions: group.extensions
              ?.map((String extension) => '*.$extension')
              .toList() ??
          <String>[],
      mimeTypes: group.mimeTypes ?? <String>[]);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  input: 'pigeons/messages.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ffs'),
  dartOut: 'lib/src/messages.g.dart',
  copyrightHeader: 'pigeons/copyright.txt',
))

/// A Pigeon representation of the GTK_FILE_CHOOSER_ACTION_* options.
enum PlatformFileChooserActionType { open, chooseDirectory, save }

/// A Pigeon representation of the Linux portion of an `XTypeGroup`.
class PlatformTypeGroup {
  const PlatformTypeGroup({
    this.label = '',
    this.extensions = const <String>[],
    this.mimeTypes = const <String>[],
  });

  final String label;
  final List<String> extensions;
  final List<String> mimeTypes;
}

/// Options for GKT file chooser.
///
/// These correspond to gtk_file_chooser_set_* options.
class PlatformFileChooserOptions {
  PlatformFileChooserOptions({
    required this.allowedFileTypes,
    required this.currentFolderPath,
    required this.currentName,
    required this.acceptButtonLabel,
    this.selectMultiple,
  });

  final List<PlatformTypeGroup>? allowedFileTypes;
  final String? currentFolderPath;
  final String? currentName;
  final String? acceptButtonLabel;

  /// Whether to allow multiple file selection.
  ///
  /// Nullable because it does not apply to the "save" action.
  final bool? selectMultiple;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  /// Shows an file chooser with the given [type] and [options], returning the
  /// list of selected paths.
  ///
  /// An empty list corresponds to a cancelled selection.
  List<String> showFileChooser(
      PlatformFileChooserActionType type, PlatformFileChooserOptions options);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_linux/src/messages.g.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late FakeFileSelectorApi api;
  late FileSelectorLinux plugin;

  setUp(() {
    api = FakeFileSelectorApi();
    plugin = FileSelectorLinux(api: api);
  });

  test('registers instance', () {
    FileSelectorLinux.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorLinux>());
  });

  group('openFile', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.openFile())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('handles empty return for cancel', () async {
      api.result = <String>[];

      expect(await plugin.openFile(), null);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFile(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFile(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('openFiles', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      final List<XFile> files = await plugin.openFiles();

      expect(files.length, 2);
      expect(files[0].path, api.result[0]);
      expect(files[1].path, api.result[1]);

      expect(api.passedType, PlatformFileChooserActionType.open);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.openFiles(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.openFiles(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSaveLocation', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect((await plugin.getSaveLocation())?.path, path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(initialDirectory: path));

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: button));

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getSavePath (deprecated)', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getSavePath(), path);

      expect(api.passedType, PlatformFileChooserActionType.save);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      expect(api.passedOptions?.allowedFileTypes?[0].label, group.label);
      // Extensions should be converted to *.<extension> format.
      expect(api.passedOptions?.allowedFileTypes?[0].extensions,
          <String>['*.txt']);
      expect(
          api.passedOptions?.allowedFileTypes?[0].mimeTypes, group.mimeTypes);
      expect(api.passedOptions?.allowedFileTypes?[1].label, groupTwo.label);
      expect(api.passedOptions?.allowedFileTypes?[1].extensions,
          <String>['*.jpg']);
      expect(api.passedOptions?.allowedFileTypes?[1].mimeTypes,
          groupTwo.mimeTypes);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getSavePath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Open File';
      await plugin.getSavePath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('throws for a type group that does not support Linux', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'images',
        webWildCards: <String>['images/*'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('passes a wildcard group correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'any',
      );

      await plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]);

      expect(api.passedOptions?.allowedFileTypes?[0].extensions, <String>['*']);
    });
  });

  group('getDirectoryPath', () {
    test('passes the core flags correctly', () async {
      const String path = '/foo/bar';
      api.result = <String>[path];

      expect(await plugin.getDirectoryPath(), path);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, false);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPath(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select Folder';
      await plugin.getDirectoryPath(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });
  });

  group('getDirectoryPaths', () {
    test('passes the core flags correctly', () async {
      api.result = <String>['/foo/bar', 'baz'];

      expect(await plugin.getDirectoryPaths(), api.result);

      expect(api.passedType, PlatformFileChooserActionType.chooseDirectory);
      expect(api.passedOptions?.selectMultiple, true);
    });

    test('passes initialDirectory correctly', () async {
      const String path = '/example/directory';
      await plugin.getDirectoryPaths(initialDirectory: path);

      expect(api.passedOptions?.currentFolderPath, path);
    });

    test('passes confirmButtonText correctly', () async {
      const String button = 'Select one or mode folders';
      await plugin.getDirectoryPaths(confirmButtonText: button);

      expect(api.passedOptions?.acceptButtonLabel, button);
    });

    test('passes multiple flag correctly', () async {
      await plugin.getDirectoryPaths();

      expect(api.passedOptions?.selectMultiple, true);
    });
  });
}

/// Fake implementation that stores arguments and provides a canned response.
class FakeFileSelectorApi implements FileSelectorApi {
  List<String> result = <String>[];
  PlatformFileChooserActionType? passedType;
  PlatformFileChooserOptions? passedOptions;

  @override
  Future<List<String>> showFileChooser(PlatformFileChooserActionType type,
      PlatformFileChooserOptions options) async {
    passedType = type;
    passedOptions = options;
    return result;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
import 'package:flutter/material.dart';
import 'package:gtk/gtk.dart';
import 'package:provider/provider.dart';
import 'package:yaru/yaru.dart';

const properties = [
  kGtkAlternativeButtonOrder,
  kGtkAlternativeSortArrows,
  kGtkApplicationPreferDarkTheme,
  kGtkCursorAspectRatio,
  kGtkCursorBlink,
  kGtkCursorBlinkTime,
  kGtkCursorBlinkTimeout,
  kGtkCursorThemeName,
  kGtkCursorThemeSize,
  kGtkDecorationLayout,
  kGtkDialogsUseHeader,
  kGtkDndDragThreshold,
  kGtkDoubleClickDistance,
  kGtkDoubleClickTime,
  kGtkEnableAccels,
  kGtkEnableAnimations,
  kGtkEnableEventSounds,
  kGtkEnableInputFeedbackSounds,
  kGtkEnablePrimaryPaste,
  kGtkEntryPasswordHintTimeout,
  kGtkEntrySelectOnFocus,
  kGtkErrorBell,
  kGtkFontName,
  kGtkFontconfigTimestamp,
  kGtkIconThemeName,
  kGtkImModule,
  kGtkKeyThemeName,
  kGtkKeynavUseCaret,
  kGtkLabelSelectOnFocus,
  kGtkLongPressTime,
  kGtkModules,
  kGtkOverlayScrolling,
  kGtkPrimaryButtonWarpsSlider,
  kGtkPrintBackends,
  kGtkPrintPreviewCommand,
  kGtkRecentFilesEnabled,
  kGtkRecentFilesMaxAge,
  kGtkShellShowsAppMenu,
  kGtkShellShowsDesktop,
  kGtkShellShowsMenubar,
  kGtkSoundThemeName,
  kGtkSplitCursor,
  kGtkThemeName,
  kGtkTitlebarDoubleClick,
  kGtkTitlebarMiddleClick,
  kGtkTitlebarRightClick,
  kGtkXftAntialias,
  kGtkXftDpi,
  kGtkXftHinting,
  kGtkXftHintstyle,
  kGtkXftRgba,
];

void main() {
  runApp(
    ChangeNotifierProvider(
      create: (_) => GtkSettings(),
      child: const ExampleApp(),
    ),
  );
}

class ExampleApp extends StatelessWidget {
  const ExampleApp({super.key});

  @override
  Widget build(BuildContext context) {
    return YaruTheme(
      builder: (context, yaru, builder) => MaterialApp(
        theme: yaru.theme,
        darkTheme: yaru.darkTheme,
        home: Scaffold(
          appBar: AppBar(
            title: const Text('gtk.dart'),
          ),
          body: const ExamplePage(),
        ),
      ),
    );
  }
}

class ExamplePage extends StatelessWidget {
  const ExamplePage({super.key});

  @override
  Widget build(BuildContext context) {
    return GtkApplication(
      onCommandLine: (args) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('command-line'),
            content: Text(args.toString()),
            actions: [
              OutlinedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text('Close'),
              ),
            ],
          ),
        );
      },
      onOpen: (files, hint) {
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('open $hint'),
            content: Column(
              children: files.map((f) => Text(f)).toList(),
            ),
            actions: [
              OutlinedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text('Close'),
              ),
            ],
          ),
        );
      },
      child: ListView.builder(
        itemCount: properties.length,
        itemBuilder: (context, index) => SettingsTile(properties[index]),
      ),
    );
  }
}

class SettingsTile extends StatelessWidget {
  const SettingsTile(this.property, {super.key});

  final String property;

  @override
  Widget build(BuildContext context) {
    final value = context.select((GtkSettings s) => s.getProperty(property));
    return ListTile(
      title: Text(value.toString()),
      subtitle: Text(property),
    );
  }
}
/// [gtk-alternative-button-order](https://docs.gtk.org/gtk3/property.Settings.gtk-alternative-button-order.html)
const kGtkAlternativeButtonOrder = 'gtk-alternative-button-order';

/// [gtk-alternative-sort-arrows](https://docs.gtk.org/gtk3/property.Settings.gtk-alternative-sort-arrows.html)
const kGtkAlternativeSortArrows = 'gtk-alternative-sort-arrows';

/// [gtk-application-prefer-dark-theme](https://docs.gtk.org/gtk3/property.Settings.gtk-application-prefer-dark-theme.html)
const kGtkApplicationPreferDarkTheme = 'gtk-application-prefer-dark-theme';

/// [gtk-cursor-aspect-ratio](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-aspect-ratio.html)
const kGtkCursorAspectRatio = 'gtk-cursor-aspect-ratio';

/// [gtk-cursor-blink](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink.html)
const kGtkCursorBlink = 'gtk-cursor-blink';

/// [gtk-cursor-blink-time](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink-time.html)
const kGtkCursorBlinkTime = 'gtk-cursor-blink-time';

/// [gtk-cursor-blink-timeout](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-blink-timeout.html)
const kGtkCursorBlinkTimeout = 'gtk-cursor-blink-timeout';

/// [gtk-cursor-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-theme-name.html)
const kGtkCursorThemeName = 'gtk-cursor-theme-name';

/// [gtk-cursor-theme-size](https://docs.gtk.org/gtk3/property.Settings.gtk-cursor-theme-size.html)
const kGtkCursorThemeSize = 'gtk-cursor-theme-size';

/// [gtk-decoration-layout](https://docs.gtk.org/gtk3/property.Settings.gtk-decoration-layout.html)
const kGtkDecorationLayout = 'gtk-decoration-layout';

/// [gtk-dialogs-use-header](https://docs.gtk.org/gtk3/property.Settings.gtk-dialogs-use-header.html)
const kGtkDialogsUseHeader = 'gtk-dialogs-use-header';

/// [gtk-dnd-drag-threshold](https://docs.gtk.org/gtk3/property.Settings.gtk-dnd-drag-threshold.html)
const kGtkDndDragThreshold = 'gtk-dnd-drag-threshold';

/// [gtk-double-click-distance](https://docs.gtk.org/gtk3/property.Settings.gtk-double-click-distance.html)
const kGtkDoubleClickDistance = 'gtk-double-click-distance';

/// [gtk-double-click-time](https://docs.gtk.org/gtk3/property.Settings.gtk-double-click-time.html)
const kGtkDoubleClickTime = 'gtk-double-click-time';

/// [gtk-enable-accels](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-accels.html)
const kGtkEnableAccels = 'gtk-enable-accels';

/// [gtk-enable-animations](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-animations.html)
const kGtkEnableAnimations = 'gtk-enable-animations';

/// [gtk-enable-event-sounds](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-event-sounds.html)
const kGtkEnableEventSounds = 'gtk-enable-event-sounds';

/// [gtk-enable-input-feedback-sounds](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-input-feedback-sounds.html)
const kGtkEnableInputFeedbackSounds = 'gtk-enable-input-feedback-sounds';

/// [gtk-enable-primary-paste](https://docs.gtk.org/gtk3/property.Settings.gtk-enable-primary-paste.html)
const kGtkEnablePrimaryPaste = 'gtk-enable-primary-paste';

/// [gtk-entry-password-hint-timeout](https://docs.gtk.org/gtk3/property.Settings.gtk-entry-password-hint-timeout.html)
const kGtkEntryPasswordHintTimeout = 'gtk-entry-password-hint-timeout';

/// [gtk-entry-select-on-focus](https://docs.gtk.org/gtk3/property.Settings.gtk-entry-select-on-focus.html)
const kGtkEntrySelectOnFocus = 'gtk-entry-select-on-focus';

/// [gtk-error-bell](https://docs.gtk.org/gtk3/property.Settings.gtk-error-bell.html)
const kGtkErrorBell = 'gtk-error-bell';

/// [gtk-font-name](https://docs.gtk.org/gtk3/property.Settings.gtk-font-name.html)
const kGtkFontName = 'gtk-font-name';

/// [gtk-fontconfig-timestamp](https://docs.gtk.org/gtk3/property.Settings.gtk-fontconfig-timestamp.html)
const kGtkFontconfigTimestamp = 'gtk-fontconfig-timestamp';

/// [gtk-icon-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-icon-theme-name.html)
const kGtkIconThemeName = 'gtk-icon-theme-name';

/// [gtk-im-module](https://docs.gtk.org/gtk3/property.Settings.gtk-im-module.html)
const kGtkImModule = 'gtk-im-module';

/// [gtk-key-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-key-theme-name.html)
const kGtkKeyThemeName = 'gtk-key-theme-name';

/// [gtk-keynav-use-caret](https://docs.gtk.org/gtk3/property.Settings.gtk-keynav-use-caret.html)
const kGtkKeynavUseCaret = 'gtk-keynav-use-caret';

/// [gtk-label-select-on-focus](https://docs.gtk.org/gtk3/property.Settings.gtk-label-select-on-focus.html)
const kGtkLabelSelectOnFocus = 'gtk-label-select-on-focus';

/// [gtk-long-press-time](https://docs.gtk.org/gtk3/property.Settings.gtk-long-press-time.html)
const kGtkLongPressTime = 'gtk-long-press-time';

/// [gtk-modules](https://docs.gtk.org/gtk3/property.Settings.gtk-modules.html)
const kGtkModules = 'gtk-modules';

/// [gtk-overlay-scrolling](https://docs.gtk.org/gtk3/property.Settings.gtk-overlay-scrolling.html)
const kGtkOverlayScrolling = 'gtk-overlay-scrolling';

/// [gtk-primary-button-warps-slider](https://docs.gtk.org/gtk3/property.Settings.gtk-primary-button-warps-slider.html)
const kGtkPrimaryButtonWarpsSlider = 'gtk-primary-button-warps-slider';

/// [gtk-print-backends](https://docs.gtk.org/gtk3/property.Settings.gtk-print-backends.html)
const kGtkPrintBackends = 'gtk-print-backends';

/// [gtk-print-preview-command](https://docs.gtk.org/gtk3/property.Settings.gtk-print-preview-command.html)
const kGtkPrintPreviewCommand = 'gtk-print-preview-command';

/// [gtk-recent-files-enabled](https://docs.gtk.org/gtk3/property.Settings.gtk-recent-files-enabled.html)
const kGtkRecentFilesEnabled = 'gtk-recent-files-enabled';

/// [gtk-recent-files-max-age](https://docs.gtk.org/gtk3/property.Settings.gtk-recent-files-max-age.html)
const kGtkRecentFilesMaxAge = 'gtk-recent-files-max-age';

/// [gtk-shell-shows-app-menu](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-app-menu.html)
const kGtkShellShowsAppMenu = 'gtk-shell-shows-app-menu';

/// [gtk-shell-shows-desktop](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-desktop.html)
const kGtkShellShowsDesktop = 'gtk-shell-shows-desktop';

/// [gtk-shell-shows-menubar](https://docs.gtk.org/gtk3/property.Settings.gtk-shell-shows-menubar.html)
const kGtkShellShowsMenubar = 'gtk-shell-shows-menubar';

/// [gtk-sound-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-sound-theme-name.html)
const kGtkSoundThemeName = 'gtk-sound-theme-name';

/// [gtk-split-cursor](https://docs.gtk.org/gtk3/property.Settings.gtk-split-cursor.html)
const kGtkSplitCursor = 'gtk-split-cursor';

/// [gtk-theme-name](https://docs.gtk.org/gtk3/property.Settings.gtk-theme-name.html)
const kGtkThemeName = 'gtk-theme-name';

/// [gtk-titlebar-double-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-double-click.html)
const kGtkTitlebarDoubleClick = 'gtk-titlebar-double-click';

/// [gtk-titlebar-middle-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-middle-click.html)
const kGtkTitlebarMiddleClick = 'gtk-titlebar-middle-click';

/// [gtk-titlebar-right-click](https://docs.gtk.org/gtk3/property.Settings.gtk-titlebar-right-click.html)
const kGtkTitlebarRightClick = 'gtk-titlebar-right-click';

/// [gtk-xft-antialias](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-antialias.html)
const kGtkXftAntialias = 'gtk-xft-antialias';

/// [gtk-xft-dpi](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-dpi.html)
const kGtkXftDpi = 'gtk-xft-dpi';

/// [gtk-xft-hinting](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-hinting.html)
const kGtkXftHinting = 'gtk-xft-hinting';

/// [gtk-xft-hintstyle](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-hintstyle.html)
const kGtkXftHintstyle = 'gtk-xft-hintstyle';

/// [gtk-xft-rgba](https://docs.gtk.org/gtk3/property.Settings.gtk-xft-rgba.html)
const kGtkXftRgba = 'gtk-xft-rgba';
import 'package:flutter/widgets.dart';

import 'gtk_application_notifier.dart';

/// A widget that can be used to listen to remote GTK application command-line
/// arguments and file open requests from within the widget tree.
///
/// ```dart
/// import 'package:flutter/material.dart';
/// import 'package:gtk_application/gtk_application.dart';
///
/// void main() {
///   runApp(
///     MaterialApp(
///       home: GtkApplication(
///         onCommandLine: (args) => print('command-line: $args'),
///         onOpen: (files, hint) => print('open ($hint): $files'),
///         child: // ...
///       ),
///     ),
///   );
/// }
/// ```
///
/// See also:
///  * [GtkApplicationNotifier]
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
class GtkApplication extends StatefulWidget {
  /// Creates a new [GtkApplication] with and optional [onCommandLine] and/or
  /// [onOpen] callback.
  const GtkApplication({
    super.key,
    this.child,
    this.onCommandLine,
    this.onOpen,
    this.notifier,
  });

  /// An optional child widget below this widget in the tree.
  final Widget? child;

  /// An optional listener that will be notified when the application receives
  /// remote command-line arguments.
  final GtkCommandLineListener? onCommandLine;

  /// An optional listener that will be notified when the application receives
  /// remote file open requests.
  final GtkOpenListener? onOpen;

  /// An optional notifier that will be used to listen to remote command-line
  /// arguments and file open requests. If not specified, a new notifier will be
  /// created.
  final GtkApplicationNotifier? notifier;

  @override
  State<GtkApplication> createState() => _GtkApplicationState();
}

class _GtkApplicationState extends State<GtkApplication> {
  late GtkApplicationNotifier _notifier;

  @override
  void initState() {
    super.initState();
    _initNotifier();
  }

  @override
  void didUpdateWidget(covariant GtkApplication oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.notifier != widget.notifier) {
      _cleanupNotifier();
      _initNotifier();
    }
  }

  @override
  void dispose() {
    _cleanupNotifier();
    super.dispose();
  }

  void _initNotifier() {
    _notifier = widget.notifier ?? GtkApplicationNotifier();
    _notifier.addCommandLineListener(_onCommandLine);
    _notifier.addOpenListener(_onOpen);
  }

  void _cleanupNotifier() {
    _notifier.removeCommandLineListener(_onCommandLine);
    _notifier.removeOpenListener(_onOpen);
    if (widget.notifier == null) {
      _notifier.dispose();
    }
  }

  void _onCommandLine(List<String> args) {
    widget.onCommandLine?.call(args);
  }

  void _onOpen(List<String> files, String hint) {
    widget.onOpen?.call(files, hint);
  }

  @override
  Widget build(BuildContext context) {
    return widget.child ?? const SizedBox.shrink();
  }
}
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

/// The signature of a callback that receives remote command-line arguments.
///
/// See also:
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
typedef GtkCommandLineListener = void Function(List<String> args);

/// The signature of a callback that receives remote file open requests.
///
/// See also:
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
typedef GtkOpenListener = void Function(List<String> files, String hint);

/// An object that can be used to listen to remote GTK application command-line
/// arguments and file open requests outside the widget tree.
///
/// ```dart
/// import 'package:flutter/widgets.dart';
/// import 'package:gtk_application/gtk_application.dart';
///
/// void main(List<String> args) {
///   WidgetsFlutterBinding.ensureInitialized();
///
///   final notifier = GtkApplicationNotifier(args);
///   notifier.addCommandLineListener((args) {
///     print('command-line: $args');
///   });
///   notifier.addOpenListener((files, hint) {
///     print('open ($hint): $files');
///   });
///
///   // ...
///   // notifier.dispose();
/// }
/// ```
///
/// See also:
///  * [GtkApplication]
///  * [GApplication::command-line](https://docs.gtk.org/gio/signal.Application.command-line.html)
///  * [GApplication::open](https://docs.gtk.org/gio/signal.Application.open.html)
class GtkApplicationNotifier {
  /// Creates a new [GtkApplicationNotifier]. Optionally, the initial value of
  /// [commandLine] can be provided.
  GtkApplicationNotifier([this._commandLine]) {
    _channel.setMethodCallHandler(_handleMethodCall);
  }

  List<String>? _commandLine;
  final _channel = const MethodChannel('gtk/application');
  final _commandLineListeners = <GtkCommandLineListener>[];
  final _openListeners = <GtkOpenListener>[];

  /// Returns the most recent command-line arguments.
  ///
  /// This is either the most recently received remote command-line arguments,
  /// the initial value provided via the constructor, or `null` if none of those
  /// are available.
  List<String>? get commandLine => _commandLine;

  /// Adds a [listener] that will be notified when the application receives
  /// remote command-line arguments.
  void addCommandLineListener(GtkCommandLineListener listener) {
    _commandLineListeners.add(listener);
  }

  /// Removes a previously registered remote command-line argument [listener].
  void removeCommandLineListener(GtkCommandLineListener listener) {
    _commandLineListeners.remove(listener);
  }

  /// Adds a [listener] that will be notified when the application receives
  /// remote file open requests.
  void addOpenListener(GtkOpenListener listener) {
    _openListeners.add(listener);
  }

  /// Removes a previously registered remote file open request [listener].
  void removeOpenListener(GtkOpenListener listener) {
    _openListeners.remove(listener);
  }

  /// Discards any resources used by the object. After this is called, the
  /// listeners will no longer be notified.
  void dispose() {
    _channel.setMethodCallHandler(null);
    _commandLineListeners.clear();
    _openListeners.clear();
  }

  /// Notify all the remote command-line argument listeners.
  @protected
  @visibleForTesting
  void notifyCommandLine(List<String> args) {
    _commandLine = args;
    final listeners = List.of(_commandLineListeners);
    for (final listener in listeners) {
      listener(args);
    }
  }

  /// Notify all the remote file open request listeners.
  @protected
  @visibleForTesting
  void notifyOpen({required List<String> files, required String hint}) {
    final listeners = List.of(_openListeners);
    for (final listener in listeners) {
      listener(files, hint);
    }
  }

  Future<void> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'command-line':
        final args = call.arguments as List;
        notifyCommandLine(args.cast<String>());
        break;
      case 'open':
        final args = call.arguments as Map;
        notifyOpen(
          files: (args['files'] as List).cast<String>(),
          hint: args['hint'].toString(),
        );
        break;
      default:
        throw UnsupportedError(call.method);
    }
  }
}
import 'package:flutter/foundation.dart';

import 'gtk_settings_stub.dart' if (dart.library.ffi) 'gtk_settings_real.dart';

abstract class GtkSettings implements ChangeNotifier {
  factory GtkSettings() = GtkSettingsImpl;
  Object? getProperty(String name);
  Stream<Object?> notifyProperty(String name);
  void setProperty(String name, Object value);
  void resetProperty(String name);
}
import 'dart:async';
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'gtk_settings.dart';
import 'libgtk.dart';
import 'libgtk.g.dart' as ffi;

class GtkSettingsImpl with ChangeNotifier implements GtkSettings {
  GtkSettingsImpl() {
    methodChannel.setMethodCallHandler(_handleMethodCall);
    _finalizer.attach(this, _controller, detach: this);
  }

  @visibleForTesting
  static const methodChannel = MethodChannel('gtk/settings');

  final _controller = StreamController<String>.broadcast();
  static final Finalizer<StreamController<String>> _finalizer =
      Finalizer((controller) => controller.close());

  @override
  Object? getProperty(String name) {
    return ffi.using((arena) {
      final value = arena<ffi.GValue>();
      lib.g_object_get_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
        value,
      );
      return value.toDartObject();
    });
  }

  @override
  Stream<Object?> notifyProperty(String name) {
    return _controller.stream
        .where((event) => event == name)
        .map((event) => getProperty(name));
  }

  Future<dynamic> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'notify':
        _controller.add(call.arguments);
        break;
      default:
        throw MissingPluginException('$call');
    }
    notifyListeners();
  }

  @override
  void setProperty(String name, Object value) {
    ffi.using((arena) {
      lib.g_object_set_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
        value.toNativeGValue(allocator: arena),
      );
    });
  }

  @override
  void resetProperty(String name) {
    ffi.using((arena) {
      lib.gtk_settings_reset_property(
        lib.gtk_settings_get_default().cast(),
        name.toNativeUtf8(allocator: arena).cast(),
      );
    });
  }
}
import 'package:flutter/foundation.dart';

import 'gtk_settings.dart';

class GtkSettingsImpl with ChangeNotifier implements GtkSettings {
  @override
  Object? getProperty(String name) => null;

  @override
  Stream<Object?> notifyProperty(String name) => Stream.empty();

  @override
  void setProperty(String name, Object value) {}

  @override
  void resetProperty(String name) {}
}
import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:meta/meta.dart';

import 'libgtk.g.dart';

LibGtk? _lib;
LibGtk get lib => _lib ??= LibGtk(ffi.DynamicLibrary.open('libgtk-3.so.0'));

@visibleForTesting
void overrideLibGtkForTesting(LibGtk lib) => _lib = lib;

extension GValueX on ffi.Pointer<GValue> {
  Object? toDartObject() {
    switch (ref.g_type) {
      case G_TYPE_BOOLEAN:
        return lib.g_value_get_boolean(this) != 0;
      case G_TYPE_CHAR:
        return lib.g_value_get_schar(this);
      case G_TYPE_UCHAR:
        return lib.g_value_get_uchar(this);
      case G_TYPE_INT:
        return lib.g_value_get_int(this);
      case G_TYPE_UINT:
        return lib.g_value_get_uint(this);
      case G_TYPE_LONG:
        return lib.g_value_get_long(this);
      case G_TYPE_ULONG:
        return lib.g_value_get_ulong(this);
      case G_TYPE_INT64:
        return lib.g_value_get_int64(this);
      case G_TYPE_UINT64:
        return lib.g_value_get_uint64(this);
      case G_TYPE_FLOAT:
        return lib.g_value_get_float(this);
      case G_TYPE_DOUBLE:
        return lib.g_value_get_double(this);
      case G_TYPE_STRING:
        return lib.g_value_get_string(this).cast<ffi.Utf8>().toDartString();
    }
    return null;
  }
}

extension ObjectX on Object {
  ffi.Pointer<GValue> toNativeGValue({required ffi.Allocator allocator}) {
    switch (runtimeType) {
      case bool:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_BOOLEAN);
        lib.g_value_set_boolean(gvalue, this as bool ? 1 : 0);
        return gvalue;
      case int:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_INT64);
        lib.g_value_set_int64(gvalue, this as int);
        return gvalue;
      case double:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_DOUBLE);
        lib.g_value_set_double(gvalue, this as double);
        return gvalue;
      case String:
        final gvalue = allocator<GValue>();
        lib.g_value_init(gvalue, G_TYPE_STRING);
        lib.g_value_set_string(
            gvalue, (this as String).toNativeUtf8(allocator: allocator).cast());
        return gvalue;
      default:
        throw UnsupportedError('Unsupported type: $runtimeType');
    }
  }
}
// coverage:ignore-file
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// GTK+ 3.0
class LibGtk {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibGtk(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibGtk.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<GValue> g_value_init(
    ffi.Pointer<GValue> value,
    int g_type,
  ) {
    return _g_value_init(
      value,
      g_type,
    );
  }

  late final _g_value_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GValue> Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_init');
  late final _g_value_init = _g_value_initPtr
      .asFunction<ffi.Pointer<GValue> Function(ffi.Pointer<GValue>, int)>();

  void g_value_set_instance(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> instance,
  ) {
    return _g_value_set_instance(
      value,
      instance,
    );
  }

  late final _g_value_set_instancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_instance');
  late final _g_value_set_instance = _g_value_set_instancePtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_param(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GParamSpec> param,
  ) {
    return _g_value_set_param(
      value,
      param,
    );
  }

  late final _g_value_set_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GParamSpec>)>>('g_value_set_param');
  late final _g_value_set_param = _g_value_set_paramPtr.asFunction<
      void Function(ffi.Pointer<GValue>, ffi.Pointer<_GParamSpec>)>();

  ffi.Pointer<_GParamSpec> g_value_get_param(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_param(
      value,
    );
  }

  late final _g_value_get_paramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_GParamSpec> Function(
              ffi.Pointer<GValue>)>>('g_value_get_param');
  late final _g_value_get_param = _g_value_get_paramPtr
      .asFunction<ffi.Pointer<_GParamSpec> Function(ffi.Pointer<GValue>)>();

  void g_value_set_param_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GParamSpec> param,
  ) {
    return _g_value_set_param_take_ownership(
      value,
      param,
    );
  }

  late final _g_value_set_param_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GParamSpec>)>>('g_value_set_param_take_ownership');
  late final _g_value_set_param_take_ownership =
      _g_value_set_param_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<_GParamSpec>)>();

  void g_value_set_boxed(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_boxed(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_boxed');
  late final _g_value_set_boxed = _g_value_set_boxedPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_static_boxed(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_static_boxed(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_static_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_static_boxed');
  late final _g_value_set_static_boxed = _g_value_set_static_boxedPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_boxed_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_boxed,
  ) {
    return _g_value_set_boxed_take_ownership(
      value,
      v_boxed,
    );
  }

  late final _g_value_set_boxed_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_boxed_take_ownership');
  late final _g_value_set_boxed_take_ownership =
      _g_value_set_boxed_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_boxed(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_boxed(
      value,
    );
  }

  late final _g_value_get_boxedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_boxed');
  late final _g_value_get_boxed = _g_value_get_boxedPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  int g_value_get_type() {
    return _g_value_get_type();
  }

  late final _g_value_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>(
          'g_value_get_type');
  late final _g_value_get_type =
      _g_value_get_typePtr.asFunction<int Function()>();

  void g_object_set_property(
    ffi.Pointer<GObject> object,
    ffi.Pointer<ffi.Char> property_name,
    ffi.Pointer<GValue> value,
  ) {
    return _g_object_set_property(
      object,
      property_name,
      value,
    );
  }

  late final _g_object_set_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GValue>)>>('g_object_set_property');
  late final _g_object_set_property = _g_object_set_propertyPtr.asFunction<
      void Function(
          ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>, ffi.Pointer<GValue>)>();

  void g_object_get_property(
    ffi.Pointer<GObject> object,
    ffi.Pointer<ffi.Char> property_name,
    ffi.Pointer<GValue> value,
  ) {
    return _g_object_get_property(
      object,
      property_name,
      value,
    );
  }

  late final _g_object_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<GValue>)>>('g_object_get_property');
  late final _g_object_get_property = _g_object_get_propertyPtr.asFunction<
      void Function(
          ffi.Pointer<GObject>, ffi.Pointer<ffi.Char>, ffi.Pointer<GValue>)>();

  void g_value_set_object(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_object,
  ) {
    return _g_value_set_object(
      value,
      v_object,
    );
  }

  late final _g_value_set_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_object');
  late final _g_value_set_object = _g_value_set_objectPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_object(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_object(
      value,
    );
  }

  late final _g_value_get_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_object');
  late final _g_value_get_object = _g_value_get_objectPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  void g_value_set_object_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_object,
  ) {
    return _g_value_set_object_take_ownership(
      value,
      v_object,
    );
  }

  late final _g_value_set_object_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_object_take_ownership');
  late final _g_value_set_object_take_ownership =
      _g_value_set_object_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  void g_value_set_enum(
    ffi.Pointer<GValue> value,
    int v_enum,
  ) {
    return _g_value_set_enum(
      value,
      v_enum,
    );
  }

  late final _g_value_set_enumPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_enum');
  late final _g_value_set_enum = _g_value_set_enumPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_enum(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_enum(
      value,
    );
  }

  late final _g_value_get_enumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_enum');
  late final _g_value_get_enum =
      _g_value_get_enumPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_flags(
    ffi.Pointer<GValue> value,
    int v_flags,
  ) {
    return _g_value_set_flags(
      value,
      v_flags,
    );
  }

  late final _g_value_set_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedInt)>>('g_value_set_flags');
  late final _g_value_set_flags = _g_value_set_flagsPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_flags(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_flags(
      value,
    );
  }

  late final _g_value_get_flagsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GValue>)>>(
      'g_value_get_flags');
  late final _g_value_get_flags =
      _g_value_get_flagsPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_schar(
    ffi.Pointer<GValue> value,
    int v_char,
  ) {
    return _g_value_set_schar(
      value,
      v_char,
    );
  }

  late final _g_value_set_scharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.SignedChar)>>('g_value_set_schar');
  late final _g_value_set_schar = _g_value_set_scharPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_schar(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_schar(
      value,
    );
  }

  late final _g_value_get_scharPtr =
      _lookup<ffi.NativeFunction<ffi.SignedChar Function(ffi.Pointer<GValue>)>>(
          'g_value_get_schar');
  late final _g_value_get_schar =
      _g_value_get_scharPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uchar(
    ffi.Pointer<GValue> value,
    int v_uchar,
  ) {
    return _g_value_set_uchar(
      value,
      v_uchar,
    );
  }

  late final _g_value_set_ucharPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedChar)>>('g_value_set_uchar');
  late final _g_value_set_uchar = _g_value_set_ucharPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uchar(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uchar(
      value,
    );
  }

  late final _g_value_get_ucharPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedChar Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uchar');
  late final _g_value_get_uchar =
      _g_value_get_ucharPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_boolean(
    ffi.Pointer<GValue> value,
    int v_boolean,
  ) {
    return _g_value_set_boolean(
      value,
      v_boolean,
    );
  }

  late final _g_value_set_booleanPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_boolean');
  late final _g_value_set_boolean = _g_value_set_booleanPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_boolean(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_boolean(
      value,
    );
  }

  late final _g_value_get_booleanPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_boolean');
  late final _g_value_get_boolean =
      _g_value_get_booleanPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_int(
    ffi.Pointer<GValue> value,
    int v_int,
  ) {
    return _g_value_set_int(
      value,
      v_int,
    );
  }

  late final _g_value_set_intPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Int)>>(
      'g_value_set_int');
  late final _g_value_set_int =
      _g_value_set_intPtr.asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_int(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_int(
      value,
    );
  }

  late final _g_value_get_intPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<GValue>)>>(
          'g_value_get_int');
  late final _g_value_get_int =
      _g_value_get_intPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uint(
    ffi.Pointer<GValue> value,
    int v_uint,
  ) {
    return _g_value_set_uint(
      value,
      v_uint,
    );
  }

  late final _g_value_set_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedInt)>>('g_value_set_uint');
  late final _g_value_set_uint = _g_value_set_uintPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uint(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uint(
      value,
    );
  }

  late final _g_value_get_uintPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uint');
  late final _g_value_get_uint =
      _g_value_get_uintPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_long(
    ffi.Pointer<GValue> value,
    int v_long,
  ) {
    return _g_value_set_long(
      value,
      v_long,
    );
  }

  late final _g_value_set_longPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Long)>>(
      'g_value_set_long');
  late final _g_value_set_long = _g_value_set_longPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_long(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_long(
      value,
    );
  }

  late final _g_value_get_longPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<GValue>)>>(
          'g_value_get_long');
  late final _g_value_get_long =
      _g_value_get_longPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_ulong(
    ffi.Pointer<GValue> value,
    int v_ulong,
  ) {
    return _g_value_set_ulong(
      value,
      v_ulong,
    );
  }

  late final _g_value_set_ulongPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_ulong');
  late final _g_value_set_ulong = _g_value_set_ulongPtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_ulong(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_ulong(
      value,
    );
  }

  late final _g_value_get_ulongPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_ulong');
  late final _g_value_get_ulong =
      _g_value_get_ulongPtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_int64(
    ffi.Pointer<GValue> value,
    int v_int64,
  ) {
    return _g_value_set_int64(
      value,
      v_int64,
    );
  }

  late final _g_value_set_int64Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<GValue>, ffi.Long)>>(
      'g_value_set_int64');
  late final _g_value_set_int64 = _g_value_set_int64Ptr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_int64(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_int64(
      value,
    );
  }

  late final _g_value_get_int64Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<GValue>)>>(
          'g_value_get_int64');
  late final _g_value_get_int64 =
      _g_value_get_int64Ptr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_uint64(
    ffi.Pointer<GValue> value,
    int v_uint64,
  ) {
    return _g_value_set_uint64(
      value,
      v_uint64,
    );
  }

  late final _g_value_set_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_uint64');
  late final _g_value_set_uint64 = _g_value_set_uint64Ptr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_uint64(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_uint64(
      value,
    );
  }

  late final _g_value_get_uint64Ptr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_uint64');
  late final _g_value_get_uint64 =
      _g_value_get_uint64Ptr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_float(
    ffi.Pointer<GValue> value,
    double v_float,
  ) {
    return _g_value_set_float(
      value,
      v_float,
    );
  }

  late final _g_value_set_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.Float)>>('g_value_set_float');
  late final _g_value_set_float = _g_value_set_floatPtr
      .asFunction<void Function(ffi.Pointer<GValue>, double)>();

  double g_value_get_float(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_float(
      value,
    );
  }

  late final _g_value_get_floatPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<GValue>)>>(
          'g_value_get_float');
  late final _g_value_get_float =
      _g_value_get_floatPtr.asFunction<double Function(ffi.Pointer<GValue>)>();

  void g_value_set_double(
    ffi.Pointer<GValue> value,
    double v_double,
  ) {
    return _g_value_set_double(
      value,
      v_double,
    );
  }

  late final _g_value_set_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.Double)>>('g_value_set_double');
  late final _g_value_set_double = _g_value_set_doublePtr
      .asFunction<void Function(ffi.Pointer<GValue>, double)>();

  double g_value_get_double(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_double(
      value,
    );
  }

  late final _g_value_get_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<GValue>)>>(
          'g_value_get_double');
  late final _g_value_get_double =
      _g_value_get_doublePtr.asFunction<double Function(ffi.Pointer<GValue>)>();

  void g_value_set_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_string');
  late final _g_value_set_string = _g_value_set_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  void g_value_set_static_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_static_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_static_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_static_string');
  late final _g_value_set_static_string = _g_value_set_static_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  void g_value_set_interned_string(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_interned_string(
      value,
      v_string,
    );
  }

  late final _g_value_set_interned_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_interned_string');
  late final _g_value_set_interned_string = _g_value_set_interned_stringPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> g_value_get_string(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_string(
      value,
    );
  }

  late final _g_value_get_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<GValue>)>>('g_value_get_string');
  late final _g_value_get_string = _g_value_get_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<GValue>)>();

  void g_value_set_pointer(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Void> v_pointer,
  ) {
    return _g_value_set_pointer(
      value,
      v_pointer,
    );
  }

  late final _g_value_set_pointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Void>)>>('g_value_set_pointer');
  late final _g_value_set_pointer = _g_value_set_pointerPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> g_value_get_pointer(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_pointer(
      value,
    );
  }

  late final _g_value_get_pointerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<GValue>)>>('g_value_get_pointer');
  late final _g_value_get_pointer = _g_value_get_pointerPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<GValue>)>();

  void g_value_set_gtype(
    ffi.Pointer<GValue> value,
    int v_gtype,
  ) {
    return _g_value_set_gtype(
      value,
      v_gtype,
    );
  }

  late final _g_value_set_gtypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<GValue>, ffi.UnsignedLong)>>('g_value_set_gtype');
  late final _g_value_set_gtype = _g_value_set_gtypePtr
      .asFunction<void Function(ffi.Pointer<GValue>, int)>();

  int g_value_get_gtype(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_gtype(
      value,
    );
  }

  late final _g_value_get_gtypePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<GValue>)>>(
      'g_value_get_gtype');
  late final _g_value_get_gtype =
      _g_value_get_gtypePtr.asFunction<int Function(ffi.Pointer<GValue>)>();

  void g_value_set_variant(
    ffi.Pointer<GValue> value,
    ffi.Pointer<_GVariant> variant,
  ) {
    return _g_value_set_variant(
      value,
      variant,
    );
  }

  late final _g_value_set_variantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<_GVariant>)>>('g_value_set_variant');
  late final _g_value_set_variant = _g_value_set_variantPtr
      .asFunction<void Function(ffi.Pointer<GValue>, ffi.Pointer<_GVariant>)>();

  ffi.Pointer<_GVariant> g_value_get_variant(
    ffi.Pointer<GValue> value,
  ) {
    return _g_value_get_variant(
      value,
    );
  }

  late final _g_value_get_variantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_GVariant> Function(
              ffi.Pointer<GValue>)>>('g_value_get_variant');
  late final _g_value_get_variant = _g_value_get_variantPtr
      .asFunction<ffi.Pointer<_GVariant> Function(ffi.Pointer<GValue>)>();

  void g_value_set_string_take_ownership(
    ffi.Pointer<GValue> value,
    ffi.Pointer<ffi.Char> v_string,
  ) {
    return _g_value_set_string_take_ownership(
      value,
      v_string,
    );
  }

  late final _g_value_set_string_take_ownershipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GValue>,
              ffi.Pointer<ffi.Char>)>>('g_value_set_string_take_ownership');
  late final _g_value_set_string_take_ownership =
      _g_value_set_string_take_ownershipPtr.asFunction<
          void Function(ffi.Pointer<GValue>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<GtkSettings> gtk_settings_get_default() {
    return _gtk_settings_get_default();
  }

  late final _gtk_settings_get_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<GtkSettings> Function()>>(
          'gtk_settings_get_default');
  late final _gtk_settings_get_default = _gtk_settings_get_defaultPtr
      .asFunction<ffi.Pointer<GtkSettings> Function()>();

  void gtk_settings_reset_property(
    ffi.Pointer<GtkSettings> settings,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _gtk_settings_reset_property(
      settings,
      name,
    );
  }

  late final _gtk_settings_reset_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<GtkSettings>,
              ffi.Pointer<ffi.Char>)>>('gtk_settings_reset_property');
  late final _gtk_settings_reset_property =
      _gtk_settings_reset_propertyPtr.asFunction<
          void Function(ffi.Pointer<GtkSettings>, ffi.Pointer<ffi.Char>)>();
}

/// GValue:
///
/// An opaque structure used to hold different types of values.
///
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
///
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
final class _GValue extends ffi.Struct {
  @ffi.UnsignedLong()
  external int g_type;

  @ffi.Array.multi([2])
  external ffi.Array<UnnamedUnion1> data;
}

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int()
  external int v_int;

  @ffi.UnsignedInt()
  external int v_uint;

  @ffi.Long()
  external int v_long;

  @ffi.UnsignedLong()
  external int v_ulong;

  @ffi.Long()
  external int v_int64;

  @ffi.UnsignedLong()
  external int v_uint64;

  @ffi.Float()
  external double v_float;

  @ffi.Double()
  external double v_double;

  external ffi.Pointer<ffi.Void> v_pointer;
}

typedef GValue = _GValue;

/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
final class _GParamSpec extends ffi.Struct {
  external _GTypeInstance g_type_instance;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Int32()
  external int flags;

  @ffi.UnsignedLong()
  external int value_type;

  @ffi.UnsignedLong()
  external int owner_type;

  external ffi.Pointer<ffi.Char> _nick;

  external ffi.Pointer<ffi.Char> _blurb;

  external ffi.Pointer<_GData> qdata;

  @ffi.UnsignedInt()
  external int ref_count;

  @ffi.UnsignedInt()
  external int param_id;
}

/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
final class _GTypeInstance extends ffi.Struct {
  external ffi.Pointer<_GTypeClass> g_class;
}

/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
final class _GTypeClass extends ffi.Struct {
  @ffi.UnsignedLong()
  external int g_type;
}

/// GParamFlags:
/// @G_PARAM_READABLE: the parameter is readable
/// @G_PARAM_WRITABLE: the parameter is writable
/// @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
/// @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
/// @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
/// @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
/// strict validation is not required
/// @G_PARAM_STATIC_NAME: the string used as name when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_NICK: the string used as nick when constructing the
/// parameter is guaranteed to remain valid and
/// unmmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
/// property will not automatically result in a "notify" signal being
/// emitted: the implementation must call g_object_notify() themselves
/// in case the property actually changes.  Since: 2.42.
/// @G_PARAM_PRIVATE: internal
/// @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
/// in a future version. A warning will be generated if it is used
/// while running with G_ENABLE_DIAGNOSTIC=1.
/// Since 2.26
///
/// Through the #GParamFlags flag values, certain aspects of parameters
/// can be configured.
///
/// See also: %G_PARAM_STATIC_STRINGS
abstract class GParamFlags {
  static const int G_PARAM_READABLE = 1;
  static const int G_PARAM_WRITABLE = 2;
  static const int G_PARAM_READWRITE = 3;
  static const int G_PARAM_CONSTRUCT = 4;
  static const int G_PARAM_CONSTRUCT_ONLY = 8;
  static const int G_PARAM_LAX_VALIDATION = 16;
  static const int G_PARAM_STATIC_NAME = 32;
  static const int G_PARAM_PRIVATE = 32;
  static const int G_PARAM_STATIC_NICK = 64;
  static const int G_PARAM_STATIC_BLURB = 128;
  static const int G_PARAM_EXPLICIT_NOTIFY = 1073741824;
  static const int G_PARAM_DEPRECATED = -2147483648;
}

final class _GData extends ffi.Opaque {}

/// GObject:
///
/// The base object type.
///
/// All the fields in the `GObject` structure are private to the implementation
/// and should never be accessed directly.
///
/// Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
/// alignment of the largest basic GLib type (typically this is #guint64 or
/// #gdouble). If you need larger alignment for an element in a #GObject, you
/// should allocate it on the heap (aligned), or arrange for your #GObject to be
/// appropriately padded. This guarantee applies to the #GObject (or derived)
/// struct, the #GObjectClass (or derived) struct, and any private data allocated
/// by G_ADD_PRIVATE().
final class _GObject extends ffi.Struct {
  external _GTypeInstance g_type_instance;

  @ffi.UnsignedInt()
  external int ref_count;

  external ffi.Pointer<_GData> qdata;
}

typedef GObject = _GObject;

final class _GVariant extends ffi.Opaque {}

final class _GtkSettings extends ffi.Struct {
  external GObject parent_instance;

  external ffi.Pointer<_GtkSettingsPrivate> priv;
}

final class _GtkSettingsPrivate extends ffi.Opaque {}

typedef GtkSettings = _GtkSettings;

const int G_TYPE_FUNDAMENTAL_MAX = 1020;

const int G_TYPE_INVALID = 0;

const int G_TYPE_NONE = 4;

const int G_TYPE_INTERFACE = 8;

const int G_TYPE_CHAR = 12;

const int G_TYPE_UCHAR = 16;

const int G_TYPE_BOOLEAN = 20;

const int G_TYPE_INT = 24;

const int G_TYPE_UINT = 28;

const int G_TYPE_LONG = 32;

const int G_TYPE_ULONG = 36;

const int G_TYPE_INT64 = 40;

const int G_TYPE_UINT64 = 44;

const int G_TYPE_ENUM = 48;

const int G_TYPE_FLAGS = 52;

const int G_TYPE_FLOAT = 56;

const int G_TYPE_DOUBLE = 60;

const int G_TYPE_STRING = 64;

const int G_TYPE_POINTER = 68;

const int G_TYPE_BOXED = 72;

const int G_TYPE_PARAM = 76;

const int G_TYPE_OBJECT = 80;

const int G_TYPE_VARIANT = 84;

const int G_TYPE_FUNDAMENTAL_SHIFT = 2;

const int G_TYPE_RESERVED_GLIB_FIRST = 22;

const int G_TYPE_RESERVED_GLIB_LAST = 31;

const int G_TYPE_RESERVED_BSE_FIRST = 32;

const int G_TYPE_RESERVED_BSE_LAST = 48;

const int G_TYPE_RESERVED_USER_FIRST = 49;

const int G_TYPE_FLAG_RESERVED_ID_BIT = 1;
library gtk;

export 'src/constants.dart';
export 'src/gtk_application.dart';
export 'src/gtk_application_notifier.dart';
export 'src/gtk_settings.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';

import 'test_utils.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  test('command-line', () async {
    final notifier = GtkApplicationNotifier(['foo']);
    expect(notifier.commandLine, ['foo']);

    final receivedArgs = <List<String>>[];
    notifier.addCommandLineListener(receivedArgs.add);

    await receiveMethodCall('gtk/application', 'command-line', ['foo', 'bar']);
    expect(receivedArgs, [
      ['foo', 'bar']
    ]);
    expect(notifier.commandLine, ['foo', 'bar']);

    await receiveMethodCall('gtk/application', 'command-line', ['baz qux']);
    expect(receivedArgs, [
      ['foo', 'bar'],
      ['baz qux'],
    ]);
    expect(notifier.commandLine, ['baz qux']);

    receivedArgs.clear();
    notifier.removeCommandLineListener(receivedArgs.add);

    await receiveMethodCall('gtk/application', 'command-line', ['none']);
    expect(receivedArgs, isEmpty);
    expect(notifier.commandLine, ['none']);
  });

  test('open', () async {
    final notifier = GtkApplicationNotifier();

    final receivedFiles = <List<String>>[];
    final receivedHints = <String>[];

    void receiveOpen(List<String> files, String hint) {
      receivedFiles.add(files);
      receivedHints.add(hint);
    }

    notifier.addOpenListener(receiveOpen);

    await receiveMethodCall('gtk/application', 'open', {
      'files': ['foo', 'bar'],
      'hint': 'baz'
    });
    expect(receivedFiles, [
      ['foo', 'bar']
    ]);
    expect(receivedHints, ['baz']);

    await receiveMethodCall('gtk/application', 'open', {
      'files': ['baz qux'],
      'hint': 'quux'
    });
    expect(receivedFiles, [
      ['foo', 'bar'],
      ['baz qux'],
    ]);
    expect(receivedHints, ['baz', 'quux']);

    receivedFiles.clear();
    receivedHints.clear();
    notifier.removeOpenListener(receiveOpen);

    await receiveMethodCall('gtk/application', 'open', {
      'files': <String>[],
      'hint': '',
    });
    expect(receivedFiles, isEmpty);
    expect(receivedHints, isEmpty);
  });
}
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';

import 'test_utils.dart';

void main() {
  testWidgets('command-line', (tester) async {
    final receivedArgs = <List<String>>[];
    final notifier = GtkApplicationNotifier();

    await tester.pumpWidget(GtkApplication(
      notifier: notifier,
      onCommandLine: receivedArgs.add,
    ));

    notifier.notifyCommandLine(['foo', 'bar']);
    expect(receivedArgs, [
      ['foo', 'bar']
    ]);

    await tester.pumpWidget(const GtkApplication());

    receivedArgs.clear();

    await receiveMethodCall('gtk/application', 'command-line', ['none']);
    expect(receivedArgs, isEmpty);
  });

  testWidgets('open', (tester) async {
    final receivedFiles = <List<String>>[];
    final receivedHints = <String>[];
    final notifier = GtkApplicationNotifier();

    void receiveOpen(List<String> files, String hint) {
      receivedFiles.add(files);
      receivedHints.add(hint);
    }

    await tester.pumpWidget(GtkApplication(
      notifier: notifier,
      onOpen: receiveOpen,
    ));

    notifier.notifyOpen(files: ['foo', 'bar'], hint: 'baz');
    expect(receivedFiles, [
      ['foo', 'bar']
    ]);
    expect(receivedHints, ['baz']);

    await tester.pumpWidget(const GtkApplication());

    receivedFiles.clear();
    receivedHints.clear();

    await receiveMethodCall('gtk/application', 'open', {
      'files': <String>[],
      'hint': '',
    });
    expect(receivedFiles, isEmpty);
    expect(receivedHints, isEmpty);
  });

  testWidgets('rebuild', (tester) async {
    var onCommandLine1 = 0;
    var onOpen1 = 0;
    final notifier1 = GtkApplicationNotifier();
    await tester.pumpWidget(
      GtkApplication(
        notifier: notifier1,
        onCommandLine: (_) => onCommandLine1++,
        onOpen: (_, __) => onOpen1++,
      ),
    );
    notifier1.notifyCommandLine(['foo']);
    expect(onCommandLine1, 1);
    notifier1.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen1, 1);

    var onCommandLine2 = 0;
    var onOpen2 = 0;
    final notifier2 = GtkApplicationNotifier();
    await tester.pumpWidget(
      GtkApplication(
        notifier: notifier2,
        onCommandLine: (_) => onCommandLine2++,
        onOpen: (_, __) => onOpen2++,
      ),
    );
    notifier2.notifyCommandLine(['foo']);
    expect(onCommandLine2, 1);
    notifier2.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen2, 1);

    notifier1.notifyCommandLine(['foo']);
    expect(onCommandLine1, 1);
    notifier1.notifyOpen(files: ['foo'], hint: 'bar');
    expect(onOpen1, 1);
  });
}
import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/gtk.dart';
import 'package:gtk/src/libgtk.g.dart' hide GtkSettings;

import 'test_utils.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  test('boolean', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'boolean': MockGValue(G_TYPE_BOOLEAN, true),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('boolean'), true);
      settings.setProperty('boolean', false);
      expect(settings.getProperty('boolean'), false);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('boolean')
          .listen(expectAsync1((value) => expect(value, false), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'boolean');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('boolean');
      expect(settings.getProperty('boolean'), isNull);
    });
  });

  test('int', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'int': MockGValue(G_TYPE_INT64, -123456789),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('int'), -123456789);
      settings.setProperty('int', -987654321);
      expect(settings.getProperty('int'), -987654321);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('int')
          .listen(expectAsync1((value) => expect(value, -987654321), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'int');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('int');
      expect(settings.getProperty('int'), isNull);
    });
  });

  test('double', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'double': MockGValue(G_TYPE_DOUBLE, 123456.789),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('double'), 123456.789);
      settings.setProperty('double', 789012.345);
      expect(settings.getProperty('double'), 789012.345);

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('double')
          .listen(expectAsync1((value) => expect(value, 789012.345), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'double');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('double');
      expect(settings.getProperty('double'), isNull);
    });
  });

  test('string', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {
        'string': MockGValue(G_TYPE_STRING, 'foo'),
      });

      final settings = GtkSettings();

      expect(settings.getProperty('string'), 'foo');
      settings.setProperty('string', 'bar');
      expect(settings.getProperty('string'), 'bar');

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      settings
          .notifyProperty('string')
          .listen(expectAsync1((value) => expect(value, 'bar'), count: 1));
      await receiveMethodCall('gtk/settings', 'notify', 'string');
      expect(wasNotified, ++expectedNotified);

      settings.resetProperty('string');
      expect(settings.getProperty('string'), isNull);

      await receiveMethodCall('gtk/settings', 'notify', 'other');
      expect(wasNotified, ++expectedNotified);
    });
  });

  test('other', () async {
    ffi.using((arena) async {
      // ignore: unused_local_variable
      final gtk = mockLibGtk(allocator: arena, properties: {});

      final settings = GtkSettings();

      var wasNotified = 0;
      var expectedNotified = 0;
      settings.addListener(() => ++wasNotified);

      await receiveMethodCall('gtk/settings', 'notify', 'other');
      expect(wasNotified, ++expectedNotified);
    });
  });
}
// ignore_for_file: non_constant_identifier_names

import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart' as ffi;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:gtk/src/libgtk.dart';
import 'package:gtk/src/libgtk.g.dart' as ffi;
import 'package:mockito/mockito.dart';

import 'test_utils.mocks.dart';

Future<void> receiveMethodCall(
  String channel,
  String method, [
  dynamic arguments,
]) async {
  const codec = StandardMethodCodec();
  final messenger =
      TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger;

  await messenger.handlePlatformMessage(
    channel,
    codec.encodeMethodCall(MethodCall(method, arguments)),
    (_) {},
  );
}

class MockGValue {
  const MockGValue(this.t, this.v);
  final int t;
  final dynamic v;
}

MockLibGtk mockLibGtk({
  required ffi.Allocator allocator,
  required Map<String, MockGValue> properties,
}) {
  final gtk = ffi.LibGtk(ffi.DynamicLibrary.open('libgtk-3.so.0'));

  final settings = ffi.Pointer<ffi.GtkSettings>.fromAddress(0x1234);

  final mock = MockLibGtk();
  overrideLibGtkForTesting(mock);
  when(mock.gtk_settings_get_default()).thenReturn(settings);

  when(mock.g_object_get_property(settings, any, any)).thenAnswer((i) {
    final key = i.positionalArguments[1] as ffi.Pointer<ffi.Char>;
    final value = properties[key.cast<ffi.Utf8>().toDartString()];
    if (value != null) {
      final ret = i.positionalArguments[2] as ffi.Pointer<ffi.GValue>;
      gtk.g_value_init(ret, value.t);
      switch (value.t) {
        case ffi.G_TYPE_BOOLEAN:
          gtk.g_value_set_boolean(ret, value.v as bool ? 1 : 0);
          when(mock.g_value_get_boolean(ret)).thenReturn(value.v ? 1 : 0);
          break;
        case ffi.G_TYPE_CHAR:
          gtk.g_value_set_schar(ret, value.v as int);
          when(mock.g_value_get_schar(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UCHAR:
          gtk.g_value_set_uchar(ret, value.v as int);
          when(mock.g_value_get_uchar(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_INT:
          gtk.g_value_set_int(ret, value.v as int);
          when(mock.g_value_get_int(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UINT:
          gtk.g_value_set_uint(ret, value.v as int);
          when(mock.g_value_get_uint(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_LONG:
          gtk.g_value_set_long(ret, value.v as int);
          when(mock.g_value_get_long(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_ULONG:
          gtk.g_value_set_ulong(ret, value.v as int);
          when(mock.g_value_get_ulong(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_INT64:
          gtk.g_value_set_int64(ret, value.v as int);
          when(mock.g_value_get_int64(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_UINT64:
          gtk.g_value_set_uint64(ret, value.v as int);
          when(mock.g_value_get_uint64(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_FLOAT:
          gtk.g_value_set_float(ret, value.v as double);
          when(mock.g_value_get_float(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_DOUBLE:
          gtk.g_value_set_double(ret, value.v as double);
          when(mock.g_value_get_double(ret)).thenReturn(value.v);
          break;
        case ffi.G_TYPE_STRING:
          final str = (value.v as String).toNativeUtf8(allocator: allocator);
          gtk.g_value_set_string(ret, str.cast());
          when(mock.g_value_get_string(ret)).thenReturn(str.cast());
          break;
        default:
          throw ArgumentError('${value.v} (${value.t})');
      }
    }
  });

  when(mock.g_object_set_property(settings, any, any)).thenAnswer((i) {
    final key = (i.positionalArguments[1] as ffi.Pointer<ffi.Char>)
        .cast<ffi.Utf8>()
        .toDartString();
    final value = i.positionalArguments[2] as ffi.Pointer<ffi.GValue>;
    final t = value.ref.g_type;
    dynamic v;
    switch (t) {
      case ffi.G_TYPE_BOOLEAN:
        v = gtk.g_value_get_boolean(value) != 0;
        break;
      case ffi.G_TYPE_CHAR:
        v = gtk.g_value_get_schar(value);
        break;
      case ffi.G_TYPE_UCHAR:
        v = gtk.g_value_get_uchar(value);
        break;
      case ffi.G_TYPE_INT:
        v = gtk.g_value_get_int(value);
        break;
      case ffi.G_TYPE_UINT:
        v = gtk.g_value_get_uint(value);
        break;
      case ffi.G_TYPE_LONG:
        v = gtk.g_value_get_long(value);
        break;
      case ffi.G_TYPE_ULONG:
        v = gtk.g_value_get_ulong(value);
        break;
      case ffi.G_TYPE_INT64:
        v = gtk.g_value_get_int64(value);
        break;
      case ffi.G_TYPE_UINT64:
        v = gtk.g_value_get_uint64(value);
        break;
      case ffi.G_TYPE_FLOAT:
        v = gtk.g_value_get_float(value);
        break;
      case ffi.G_TYPE_DOUBLE:
        v = gtk.g_value_get_double(value);
        break;
      case ffi.G_TYPE_STRING:
        v = gtk.g_value_get_string(value).cast<ffi.Utf8>().toDartString();
        break;
      default:
        throw ArgumentError.value(value.ref.g_type);
    }
    properties[key] = MockGValue(t, v);
  });

  when(mock.gtk_settings_reset_property(settings, any)).thenAnswer((i) {
    final key = (i.positionalArguments[1] as ffi.Pointer<ffi.Char>)
        .cast<ffi.Utf8>()
        .toDartString();
    properties.remove(key);
  });

  when(mock.g_value_init(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_init(value, i.positionalArguments[1] as int);
    return value;
  });
  when(mock.g_value_set_boolean(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_boolean(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_schar(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_schar(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uchar(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uchar(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_int(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_int(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uint(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uint(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_long(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_long(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_ulong(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_ulong(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_int64(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_int64(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_uint64(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_uint64(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_float(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_float(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_double(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_double(value, i.positionalArguments[1]);
  });
  when(mock.g_value_set_string(any, any)).thenAnswer((i) {
    final value = i.positionalArguments[0] as ffi.Pointer<ffi.GValue>;
    gtk.g_value_set_string(value, i.positionalArguments[1]);
  });

  return mock;
}
// ignore_for_file: non_constant_identifier_names

import 'dart:ffi' as ffi;

import 'package:gtk/src/libgtk.g.dart';
import 'package:mockito/mockito.dart';

class MockLibGtk extends Mock implements LibGtk {
  @override
  ffi.Pointer<GtkSettings> gtk_settings_get_default() {
    return super.noSuchMethod(
      Invocation.method(#gtk_settings_get_default, []),
      returnValue: ffi.nullptr,
    );
  }

  @override
  void gtk_settings_reset_property(ffi.Pointer? settings, ffi.Pointer? name) {
    return super.noSuchMethod(
      Invocation.method(#gtk_settings_reset_property, [settings, name]),
    );
  }

  @override
  void g_object_get_property(ffi.Pointer? object,
      ffi.Pointer<ffi.Char>? property_name, ffi.Pointer? value) {
    return super.noSuchMethod(Invocation.method(#g_object_get_property, [
      object,
      property_name,
      value,
    ]));
  }

  @override
  void g_object_set_property(ffi.Pointer? object,
      ffi.Pointer<ffi.Char>? property_name, ffi.Pointer? value) {
    return super.noSuchMethod(Invocation.method(#g_object_set_property, [
      object,
      property_name,
      value,
    ]));
  }

  @override
  ffi.Pointer<GValue> g_value_init(ffi.Pointer? value, int? g_type) {
    return super.noSuchMethod(
      Invocation.method(#g_value_init, [value, g_type]),
      returnValue: ffi.nullptr,
    );
  }

  @override
  int g_value_get_boolean(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_boolean, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_boolean(ffi.Pointer? value, int? v_boolean) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_boolean, [value, v_boolean]),
    );
  }

  @override
  int g_value_get_schar(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_schar, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_schar(ffi.Pointer? value, int? v_char) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_schar, [value, v_char]),
    );
  }

  @override
  int g_value_get_uchar(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uchar, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uchar(ffi.Pointer? value, int? v_uchar) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uchar, [value, v_uchar]),
    );
  }

  @override
  int g_value_get_int(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_int, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_int(ffi.Pointer? value, int? v_int) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_int, [value, v_int]),
    );
  }

  @override
  int g_value_get_uint(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uint, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uint(ffi.Pointer? value, int? v_uint) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uint, [value, v_uint]),
    );
  }

  @override
  int g_value_get_long(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_long, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_long(ffi.Pointer? value, int? v_long) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_long, [value, v_long]),
    );
  }

  @override
  int g_value_get_ulong(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_ulong, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_ulong(ffi.Pointer? value, int? v_ulong) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_ulong, [value, v_ulong]),
    );
  }

  @override
  int g_value_get_int64(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_int64, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_int64(ffi.Pointer? value, int? v_int64) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_int64, [value, v_int64]),
    );
  }

  @override
  int g_value_get_uint64(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_uint64, [value]),
      returnValue: 0,
    );
  }

  @override
  void g_value_set_uint64(ffi.Pointer? value, int? v_uint64) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_uint64, [value, v_uint64]),
    );
  }

  @override
  double g_value_get_float(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_float, [value]),
      returnValue: 0.0,
    );
  }

  @override
  void g_value_set_float(ffi.Pointer? value, double? v_float) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_float, [value, v_float]),
    );
  }

  @override
  double g_value_get_double(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_double, [value]),
      returnValue: 0.0,
    );
  }

  @override
  void g_value_set_double(ffi.Pointer? value, double? v_double) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_double, [value, v_double]),
    );
  }

  @override
  ffi.Pointer<ffi.Char> g_value_get_string(ffi.Pointer? value) {
    return super.noSuchMethod(
      Invocation.method(#g_value_get_string, [value]),
      returnValue: ffi.nullptr,
    );
  }

  @override
  void g_value_set_string(ffi.Pointer? value, ffi.Pointer? v_string) {
    return super.noSuchMethod(
      Invocation.method(#g_value_set_string, [value, v_string]),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool isMultiImage = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final XFile? file = await _picker.getVideo(
            source: source, maxDuration: const Duration(seconds: 10));
        await _playVideo(file);
      } else if (isMultiImage) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                        allowMultiple: isMultiImage,
                        imageOptions: ImageOptions(
                          maxWidth: maxWidth,
                          maxHeight: maxHeight,
                          imageQuality: quality,
                        )),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: ImageOptions(
                        maxWidth: maxWidth,
                        maxHeight: maxHeight,
                        imageQuality: quality,
                      ),
                    ),
                  );
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: isMultiImage,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            setState(() {
              _setImageFileListFromFile(pickedFile);
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Semantics(
              label: 'image_picker_example_picked_image',
              child: mime == null || mime.startsWith('image/')
                  ? Image.file(
                      File(_mediaFileList![index].path),
                      errorBuilder: (BuildContext context, Object error,
                          StackTrace? stackTrace) {
                        return const Center(
                            child: Text('This image type is not supported'));
                      },
                    )
                  : _buildInlineVideoPlayer(index),
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    const double volume = 1.0;
    controller.setVolume(volume);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Center(
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick Image from gallery',
              child: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMultiImage: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick Multiple Media from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick Single Media from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMultiImage: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick Multiple Image from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a Photo',
                child: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video0',
              tooltip: 'Pick Video from gallery',
              child: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'video1',
                tooltip: 'Take a Video',
                child: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_linux/file_selector_linux.dart';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Linux implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Linux.
class ImagePickerLinux extends CameraDelegatingImagePickerPlatform {
  /// Constructs a platform implementation.
  ImagePickerLinux();

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorLinux();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerLinux();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', mimeTypes: <String>['video/*']);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', mimeTypes: <String>['image/*']);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
        label: 'images and videos', extensions: <String>['image/*', 'video/*']);

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_linux/image_picker_linux.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_linux_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  late ImagePickerLinux plugin;
  late MockFileSelectorPlatform mockFileSelectorPlatform;

  setUp(() {
    plugin = ImagePickerLinux();
    mockFileSelectorPlatform = MockFileSelectorPlatform();

    when(mockFileSelectorPlatform.openFile(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => null);

    when(mockFileSelectorPlatform.openFiles(
            acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
        .thenAnswer((_) async => List<XFile>.empty());

    ImagePickerLinux.fileSelector = mockFileSelectorPlatform;
  });

  test('registered instance', () {
    ImagePickerLinux.registerWith();
    expect(ImagePickerPlatform.instance, isA<ImagePickerLinux>());
  });

  group('images', () {
    test('pickImage passes the accepted type groups correctly', () async {
      await plugin.pickImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImage passes the accepted type groups correctly', () async {
      await plugin.getImage(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource passes the accepted type groups correctly',
        () async {
      await plugin.getImageFromSource(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });

    test('getImageFromSource calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getImageFromSource(source: ImageSource.camera))!.path,
          fakePath);
    });

    test(
        'getImageFromSource throws StateError when source is camera with no delegate',
        () async {
      await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
          throwsStateError);
    });

    test('getMultiImage passes the accepted type groups correctly', () async {
      await plugin.getMultiImage();

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['image/*']);
    });
  });

  group('videos', () {
    test('pickVideo passes the accepted type groups correctly', () async {
      await plugin.pickVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo passes the accepted type groups correctly', () async {
      await plugin.getVideo(source: ImageSource.gallery);

      final VerificationResult result = verify(mockFileSelectorPlatform
          .openFile(acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].mimeTypes, <String>['video/*']);
    });

    test('getVideo calls delegate when source is camera', () async {
      const String fakePath = '/tmp/foo';
      plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
      expect(
          (await plugin.getVideo(source: ImageSource.camera))!.path, fakePath);
    });

    test('getVideo throws StateError when source is camera with no delegate',
        () async {
      await expectLater(
          plugin.getVideo(source: ImageSource.camera), throwsStateError);
    });
  });

  group('media', () {
    test('getMedia passes the accepted type groups correctly', () async {
      await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

      final VerificationResult result = verify(
          mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
      expect(capturedTypeGroups(result)[0].extensions,
          <String>['image/*', 'video/*']);
    });

    test('multiple media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: true,
            ),
          ),
          <String>[]);
    });

    test('single media handles an empty path response gracefully', () async {
      expect(
          await plugin.getMedia(
            options: const MediaOptions(
              allowMultiple: false,
            ),
          ),
          <String>[]);
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
// Mocks generated by Mockito 5.4.0 from annotations
// in image_picker_linux/test/image_picker_linux_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);
  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);
  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);
  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);
  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getDownloadDirectory', (WidgetTester tester) async {
    if (!Platform.isLinux) {
      return;
    }
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloadDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderLinux provider = PathProviderLinux();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path_provider_linux/path_provider_linux.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _appCacheDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  final PathProviderLinux _provider = PathProviderLinux();

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? appCacheDirectory;
    String? documentsDirectory;
    // Platform messages may fail, so we use a try/catch PlatformException.
    try {
      tempDirectory = await _provider.getTemporaryPath();
    } on PlatformException {
      tempDirectory = 'Failed to get temp directory.';
    }
    try {
      downloadsDirectory = await _provider.getDownloadsPath();
    } on PlatformException {
      downloadsDirectory = 'Failed to get downloads directory.';
    }

    try {
      documentsDirectory = await _provider.getApplicationDocumentsPath();
    } on PlatformException {
      documentsDirectory = 'Failed to get documents directory.';
    }

    try {
      appSupportDirectory = await _provider.getApplicationSupportPath();
    } on PlatformException {
      appSupportDirectory = 'Failed to get documents directory.';
    }

    try {
      appCacheDirectory = await _provider.getApplicationCachePath();
    } on PlatformException {
      appCacheDirectory = 'Failed to get cache directory.';
    }
    // If the widget was removed from the tree while the asynchronous platform
    // message was in flight, we want to discard the reply rather than calling
    // setState to update our non-existent appearance.
    if (!mounted) {
      return;
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _appCacheDirectory = appCacheDirectory;
      _documentsDirectory = documentsDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider Linux example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Application Cache Directory: $_appCacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// getApplicationId() is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'get_application_id_stub.dart'
    if (dart.library.ffi) 'get_application_id_real.dart';
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;

// GApplication* g_application_get_default();
typedef _GApplicationGetDefaultC = IntPtr Function();
typedef _GApplicationGetDefaultDart = int Function();

// const gchar* g_application_get_application_id(GApplication* application);
typedef _GApplicationGetApplicationIdC = Pointer<Utf8> Function(IntPtr);
typedef _GApplicationGetApplicationIdDart = Pointer<Utf8> Function(int);

/// Interface for interacting with libgio.
@visibleForTesting
class GioUtils {
  /// Creates a default instance that uses the real libgio.
  GioUtils() {
    try {
      _gio = DynamicLibrary.open('libgio-2.0.so');
    } on ArgumentError {
      _gio = null;
    }
  }

  DynamicLibrary? _gio;

  /// True if libgio was opened successfully.
  bool get libraryIsPresent => _gio != null;

  /// Wraps `g_application_get_default`.
  int gApplicationGetDefault() {
    if (_gio == null) {
      return 0;
    }
    final _GApplicationGetDefaultDart getDefault = _gio!
        .lookupFunction<_GApplicationGetDefaultC, _GApplicationGetDefaultDart>(
            'g_application_get_default');
    return getDefault();
  }

  /// Wraps g_application_get_application_id.
  Pointer<Utf8> gApplicationGetApplicationId(int app) {
    if (_gio == null) {
      return nullptr;
    }
    final _GApplicationGetApplicationIdDart gApplicationGetApplicationId = _gio!
        .lookupFunction<_GApplicationGetApplicationIdC,
                _GApplicationGetApplicationIdDart>(
            'g_application_get_application_id');
    return gApplicationGetApplicationId(app);
  }
}

/// Allows overriding the default GioUtils instance with a fake for testing.
@visibleForTesting
GioUtils? gioUtilsOverride;

/// Gets the application ID for this app.
String? getApplicationId() {
  final GioUtils gio = gioUtilsOverride ?? GioUtils();
  if (!gio.libraryIsPresent) {
    return null;
  }

  final int app = gio.gApplicationGetDefault();
  if (app == 0) {
    return null;
  }
  final Pointer<Utf8> appId = gio.gApplicationGetApplicationId(app);
  if (appId == nullptr) {
    return null;
  }
  return appId.toDartString();
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Gets the application ID for this app.
String? getApplicationId() => null;
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

import 'get_application_id.dart';

/// The linux implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Linux.
class PathProviderLinux extends PathProviderPlatform {
  /// Constructs an instance of [PathProviderLinux]
  PathProviderLinux() : _environment = Platform.environment;

  /// Constructs an instance of [PathProviderLinux] with the given [environment]
  @visibleForTesting
  PathProviderLinux.private(
      {Map<String, String> environment = const <String, String>{},
      String? executableName,
      String? applicationId})
      : _environment = environment,
        _executableName = executableName,
        _applicationId = applicationId;

  final Map<String, String> _environment;
  String? _executableName;
  String? _applicationId;

  /// Registers this class as the default instance of [PathProviderPlatform]
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderLinux();
  }

  @override
  Future<String?> getTemporaryPath() {
    final String environmentTmpDir = _environment['TMPDIR'] ?? '';
    return Future<String?>.value(
      environmentTmpDir.isEmpty ? '/tmp' : environmentTmpDir,
    );
  }

  @override
  Future<String?> getApplicationSupportPath() async {
    final Directory directory =
        Directory(path.join(xdg.dataHome.path, await _getId()));
    if (directory.existsSync()) {
      return directory.path;
    }

    // This plugin originally used the executable name as a directory.
    // Use that if it exists for backwards compatibility.
    final Directory legacyDirectory =
        Directory(path.join(xdg.dataHome.path, await _getExecutableName()));
    if (legacyDirectory.existsSync()) {
      return legacyDirectory.path;
    }

    // Create the directory, because mobile implementations assume the directory exists.
    await directory.create(recursive: true);
    return directory.path;
  }

  @override
  Future<String?> getApplicationDocumentsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOCUMENTS')?.path);
  }

  @override
  Future<String?> getApplicationCachePath() async {
    final Directory directory =
        Directory(path.join(xdg.cacheHome.path, await _getId()));
    if (!directory.existsSync()) {
      await directory.create(recursive: true);
    }
    return directory.path;
  }

  @override
  Future<String?> getDownloadsPath() {
    return Future<String?>.value(xdg.getUserDirectory('DOWNLOAD')?.path);
  }

  // Gets the name of this executable.
  Future<String> _getExecutableName() async {
    _executableName ??= path.basenameWithoutExtension(
        await File('/proc/self/exe').resolveSymbolicLinks());
    return _executableName!;
  }

  // Gets the unique ID for this application.
  Future<String> _getId() async {
    _applicationId ??= getApplicationId();
    // If no application ID then fall back to using the executable name.
    return _applicationId ?? await _getExecutableName();
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'src/path_provider_linux.dart';
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:ffi';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/src/get_application_id_real.dart';

class _FakeGioUtils implements GioUtils {
  int? application;
  Pointer<Utf8>? applicationId;

  @override
  bool libraryIsPresent = false;

  @override
  int gApplicationGetDefault() => application!;

  @override
  Pointer<Utf8> gApplicationGetApplicationId(int app) => applicationId!;
}

void main() {
  late _FakeGioUtils fakeGio;

  setUp(() {
    fakeGio = _FakeGioUtils();
    gioUtilsOverride = fakeGio;
  });

  tearDown(() {
    gioUtilsOverride = null;
  });

  test('returns null if libgio is not available', () {
    expect(getApplicationId(), null);
  });

  test('returns null if g_paplication_get_default returns 0', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 0;
    expect(getApplicationId(), null);
  });

  test('returns null if g_application_get_application_id returns nullptr', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    fakeGio.applicationId = nullptr;
    expect(getApplicationId(), null);
  });

  test('returns value if g_application_get_application_id returns a value', () {
    fakeGio.libraryIsPresent = true;
    fakeGio.application = 1;
    const String id = 'foo';
    final Pointer<Utf8> idPtr = id.toNativeUtf8();
    fakeGio.applicationId = idPtr;
    expect(getApplicationId(), id);
    calloc.free(idPtr);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:xdg_directories/xdg_directories.dart' as xdg;

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  PathProviderLinux.registerWith();

  test('registered instance', () {
    expect(PathProviderPlatform.instance, isA<PathProviderLinux>());
  });

  test('getTemporaryPath defaults to TMPDIR', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': '/run/user/0/tmp'},
    );
    expect(await plugin.getTemporaryPath(), '/run/user/0/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is empty', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{'TMPDIR': ''},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getTemporaryPath uses fallback if TMPDIR is unset', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
      environment: <String, String>{},
    );
    expect(await plugin.getTemporaryPath(), '/tmp');
  });

  test('getApplicationSupportPath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary',
        applicationId: 'com.example.Test');
    // Note this will fail if ${xdg.dataHome.path}/path_provider_linux_test_binary exists on the local filesystem.
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/com.example.Test');
  });

  test('getApplicationSupportPath uses executable name if no application Id',
      () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationSupportPath(),
        '${xdg.dataHome.path}/path_provider_linux_test_binary');
  });

  test('getApplicationDocumentsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getApplicationDocumentsPath(), startsWith('/'));
  });

  test('getApplicationCachePath', () async {
    final PathProviderPlatform plugin = PathProviderLinux.private(
        executableName: 'path_provider_linux_test_binary');
    expect(await plugin.getApplicationCachePath(),
        '${xdg.cacheHome.path}/path_provider_linux_test_binary');
  });

  test('getDownloadsPath', () async {
    final PathProviderPlatform plugin = PathProviderPlatform.instance;
    expect(await plugin.getDownloadsPath(), startsWith('/'));
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesLinux', () {
    late SharedPreferencesLinux preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesLinux();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesLinuxOptions emptyOptions =
        SharedPreferencesLinuxOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncLinux).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await Future.wait(<Future<void>>[
        preferences.setString(stringKey, testString, emptyOptions),
        preferences.setBool(boolKey, testBool, emptyOptions),
        preferences.setInt(intKey, testInt, emptyOptions),
        preferences.setDouble(doubleKey, testDouble, emptyOptions),
        preferences.setStringList(listKey, testList, emptyOptions)
      ]);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesLinuxOptions options =
      const SharedPreferencesLinuxOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Linux implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
class SharedPreferencesLinux extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesLinux].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesLinux instance = SharedPreferencesLinux();

  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesLinux();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncLinux.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _reload(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Linux implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Linux.
base class SharedPreferencesAsyncLinux extends SharedPreferencesAsyncPlatform {
  /// Registers the Linux implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncLinux();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_linux instance used to find the support directory.
  @visibleForTesting
  PathProviderLinux pathProvider = PathProviderLinux();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesLinuxOptions options,
  ) async {
    _cachedPreferences = await _reload(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs =
        Map<String, Object>.from(await _readPreferences(linuxOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesLinuxOptions linuxOptions =
        SharedPreferencesLinuxOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(linuxOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      linuxOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _reload(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderLinux();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file and saves them in cache.
Future<Map<String, Object>> _reload(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderLinux? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Linux specific SharedPreferences Options.
class SharedPreferencesLinuxOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesLinuxOptions.
  const SharedPreferencesLinuxOptions({
    this.fileName = 'shared_preferences',
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesLinuxOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesLinuxOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesLinuxOptions) {
      return options;
    }
    return const SharedPreferencesLinuxOptions();
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// Fake implementation of PathProviderLinux that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Linux.
class FakePathProviderLinux extends PathProviderPlatform
    implements PathProviderLinux {
  @override
  Future<String?> getApplicationSupportPath() async => r'/appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesLinux.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesLinux getPreferences() {
    final SharedPreferencesLinux prefs = SharedPreferencesLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesLinux.registerWith();
    expect(
        SharedPreferencesStorePlatform.instance, isA<SharedPreferencesLinux>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesLinux prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> someValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(someValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesLinux prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesLinux prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:shared_preferences_platform_interface/types.dart';

import 'fake_path_provider_linux.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderLinux pathProvider;

  SharedPreferencesAsyncLinux.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesLinuxOptions emptyOptions =
      SharedPreferencesLinuxOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderLinux();
  });

  SharedPreferencesAsyncLinux getPreferences() {
    final SharedPreferencesAsyncLinux prefs = SharedPreferencesAsyncLinux();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncLinux preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Returns true if the URL can definitely be launched.
  Future<bool> canLaunchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.canLaunchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Opens the URL externally, returning an error string on failure.
  Future<String?> launchUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.url_launcher_linux.UrlLauncherApi.launchUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Linux.
class UrlLauncherLinux extends UrlLauncherPlatform {
  /// Creates a new URL launcher instance.
  UrlLauncherLinux({@visibleForTesting UrlLauncherApi? api})
      : _hostApi = api ?? UrlLauncherApi();

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherLinux();
  }

  final UrlLauncherApi _hostApi;

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) async {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) {
    // None of the options are supported, so they don't need to be converted to
    // LaunchOptions.
    return launchUrl(url, const LaunchOptions());
  }

  @override
  Future<bool> launchUrl(String url, LaunchOptions options) async {
    final String? error = await _hostApi.launchUrl(url);
    if (error != null) {
      // TODO(stuartmorgan): Standardize errors across the entire plugin,
      // instead of using PlatformException. This preserves the pre-Pigeon
      // behavior of the C code returning this error response.
      throw PlatformException(
          code: 'Launch Error', message: 'Failed to launch URL: $error');
    }
    return true;
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  gobjectHeaderOut: 'linux/messages.g.h',
  gobjectSourceOut: 'linux/messages.g.cc',
  gobjectOptions: GObjectOptions(module: 'Ful'),
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi()
abstract class UrlLauncherApi {
  /// Returns true if the URL can definitely be launched.
  bool canLaunchUrl(String url);

  /// Opens the URL externally, returning an error string on failure.
  String? launchUrl(String url);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_linux/src/messages.g.dart';
import 'package:url_launcher_linux/url_launcher_linux.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  group('UrlLauncherLinux', () {
    test('registers instance', () {
      UrlLauncherLinux.registerWith();
      expect(UrlLauncherPlatform.instance, isA<UrlLauncherLinux>());
    });

    test('canLaunch passes true', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, true);
    });

    test('canLaunch passes false', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(canLaunch: false);
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      final bool canLaunch = await launcher.canLaunch('http://example.com/');

      expect(canLaunch, false);
    });

    test('launch', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
      const String url = 'http://example.com/';

      final bool launched = await launcher.launch(
        url,
        useSafariVC: true,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: const <String, String>{},
      );

      expect(launched, true);
      expect(api.argument, url);
    });

    test('launch should throw if platform returns an error', () async {
      final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
      final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

      await expectLater(
          launcher.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()
              .having((PlatformException e) => e.code, 'code', 'Launch Error')
              .having((PlatformException e) => e.message, 'message',
                  contains('Failed to launch URL: An error'))));
    });

    group('launchUrl', () {
      test('passes URL', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi();
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);
        const String url = 'http://example.com/';

        final bool launched =
            await launcher.launchUrl(url, const LaunchOptions());

        expect(launched, true);
        expect(api.argument, url);
      });

      test('throws if platform returns an error', () async {
        final _FakeUrlLauncherApi api = _FakeUrlLauncherApi(error: 'An error');
        final UrlLauncherLinux launcher = UrlLauncherLinux(api: api);

        await expectLater(
            launcher.launchUrl('http://example.com/', const LaunchOptions()),
            throwsA(isA<PlatformException>()
                .having((PlatformException e) => e.code, 'code', 'Launch Error')
                .having((PlatformException e) => e.message, 'message',
                    contains('Failed to launch URL: An error'))));
      });
    });

    group('supportsMode', () {
      test('returns true for platformDefault', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
            true);
      });

      test('returns true for external application', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher
                .supportsMode(PreferredLaunchMode.externalApplication),
            true);
      });

      test('returns false for other modes', () async {
        final UrlLauncherLinux launcher = UrlLauncherLinux();
        expect(
            await launcher.supportsMode(
                PreferredLaunchMode.externalNonBrowserApplication),
            false);
        expect(
            await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
            false);
        expect(await launcher.supportsMode(PreferredLaunchMode.inAppWebView),
            false);
      });
    });

    test('supportsCloseForMode returns false', () async {
      final UrlLauncherLinux launcher = UrlLauncherLinux();
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.platformDefault),
          false);
      expect(
          await launcher
              .supportsCloseForMode(PreferredLaunchMode.externalApplication),
          false);
    });
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  _FakeUrlLauncherApi({this.canLaunch = true, this.error});

  /// The value to return from canLaunch.
  final bool canLaunch;

  /// The error to return from launchUrl, if any.
  final String? error;

  /// The argument that was passed to an API call.
  String? argument;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<String?> launchUrl(String url) async {
    argument = url;
    return error;
  }

  @override
  // ignore: non_constant_identifier_names
  BinaryMessenger? get pigeonVar_binaryMessenger => null;

  @override
  // ignore: non_constant_identifier_names
  String get pigeonVar_messageChannelSuffix => '';
}
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:gymf/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}
import 'protocol.dart';
import 'windows_protocol.dart'
    if (dart.library.js_interop) 'web_url_protocol.dart';

/// Registers a protocol by [scheme] to allow for links in the form `<scheme>://...`
/// to be processed by this application. By default, opening a link will open
/// the executable that was used to register the scheme with the URL as the first
/// argument passed to the executable.
///
/// If a protocol is already registered for the given scheme, this function will
/// attempt to overwrite the previous handler with the current executable information.
/// However, note that depending on process permissions, this operation may be
/// disallowed by the underlying platform.
///
/// You may pass an [executable] to override the path to the executable to run
/// when accessing the URL.
///
/// [arguments] is a list of arguments to be used when running the executable.
/// If passed, the list must contain at least one element, and at least one of
/// those elements must contain the literal value `%s` to denote the URL to open.
/// Quoting arguments is not necessary, as this will be handled for you.
/// Escaping the `%s` as an unprocessed literal is currently unsupported.
void registerProtocolHandler(
  String scheme, {
  String? executable,
  List<String>? arguments,
}) {
  WindowsProtocolHandler().register(
    scheme,
    executable: executable,
    arguments: arguments,
  );
}

/// Unregisters the protocol handler with the underlying platform. The provided
/// [scheme] will no longer be used in links.
///
/// Note that this will unregister a protocol by scheme regardless of which process
/// had registered it. Unregistering a scheme that was not registered by this
/// application is undefined and depends on platform-specific restrictions.
void unregisterProtocolHandler(String scheme) {
  WindowsProtocolHandler().unregister(scheme);
}
abstract class ProtocolHandler {
  void register(String scheme, {String? executable, List<String>? arguments});

  void unregister(String scheme);

  List<String> getArguments(List<String>? arguments) {
    if (arguments == null) return ['%s'];

    if (arguments.isEmpty && !arguments.any((e) => e.contains('%s'))) {
      throw ArgumentError('arguments must contain at least 1 instance of "%s"');
    }

    return arguments;
  }
}
import './protocol.dart';

class WindowsProtocolHandler extends ProtocolHandler {
  @override
  void register(String scheme, {String? executable, List<String>? arguments}) {}

  @override
  void unregister(String scheme) {}
}
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart';
import 'package:win32/win32.dart';

import './protocol.dart';

const _hive = HKEY_CURRENT_USER;

class WindowsProtocolHandler extends ProtocolHandler {
  @override
  void register(String scheme, {String? executable, List<String>? arguments}) {
    if (defaultTargetPlatform != TargetPlatform.windows) return;

    final prefix = _regPrefix(scheme);
    final capitalized = scheme[0].toUpperCase() + scheme.substring(1);
    final args = getArguments(arguments).map((a) => _sanitize(a));
    final cmd =
        '${executable ?? Platform.resolvedExecutable} ${args.join(' ')}';

    _regCreateStringKey(_hive, prefix, '', 'URL:$capitalized');
    _regCreateStringKey(_hive, prefix, 'URL Protocol', '');
    _regCreateStringKey(_hive, '$prefix\\shell\\open\\command', '', cmd);
  }

  @override
  void unregister(String scheme) {
    if (defaultTargetPlatform != TargetPlatform.windows) return;

    final txtKey = TEXT(_regPrefix(scheme));
    try {
      RegDeleteTree(HKEY_CURRENT_USER, txtKey);
    } finally {
      free(txtKey);
    }
  }

  String _regPrefix(String scheme) => 'SOFTWARE\\Classes\\$scheme';

  int _regCreateStringKey(int hKey, String key, String valueName, String data) {
    final txtKey = TEXT(key);
    final txtValue = TEXT(valueName);
    final txtData = TEXT(data);
    try {
      return RegSetKeyValue(
        hKey,
        txtKey,
        txtValue,
        REG_SZ,
        txtData,
        txtData.length * 2 + 2,
      );
    } finally {
      free(txtKey);
      free(txtValue);
      free(txtData);
    }
  }

  String _sanitize(String value) {
    value = value.replaceAll(r'%s', '%1').replaceAll(r'"', '\\"');
    return '"$value"';
  }
}
import 'dart:async';

import 'package:app_links/app_links.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'url_protocol/api.dart';

///////////////////////////////////////////////////////////////////////////////
/// Please make sure to follow the setup instructions below
///
/// Please take a look at:
/// - example/android/app/main/AndroidManifest.xml for Android.
///
/// - example/ios/Runner/Runner.entitlements for Universal Link sample.
/// - example/ios/Runner/Info.plist for Custom URL scheme sample.
///
/// Android launch:
///    adb shell am start -a android.intent.action.VIEW \
///     -d "sample://open.my.app/#/book/hello-world"
///
/// iOS launch:
///    /usr/bin/xcrun simctl openurl booted "app://www.example.com/#/book/hello-world"
///
///
/// Windows & macOS launch:
///   The simplest way to test it is by
///   opening your browser and type: sample://foo/#/book/hello-world2
///
/// On windows:
/// Outside of a browser, in a email for example, you can use:
/// https://example.com/#/book/hello-world2
///////////////////////////////////////////////////////////////////////////////

const kWindowsScheme = 'sample';

void main() {
  // Register our protocol only on Windows platform
  // registerProtocolHandler(kWindowsScheme);

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final _navigatorKey = GlobalKey<NavigatorState>();
  StreamSubscription<Uri>? _linkSubscription;

  @override
  void initState() {
    super.initState();

    initDeepLinks();
  }

  @override
  void dispose() {
    _linkSubscription?.cancel();

    super.dispose();
  }

  Future<void> initDeepLinks() async {
    // Handle links
    _linkSubscription = AppLinks().uriLinkStream.listen((uri) {
      debugPrint('onAppLink: $uri');
      openAppLink(uri);
    });
  }

  void openAppLink(Uri uri) {
    _navigatorKey.currentState?.pushNamed(uri.fragment);
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: _navigatorKey,
      initialRoute: "/",
      onGenerateRoute: (RouteSettings settings) {
        Widget routeWidget = defaultScreen();

        // Mimic web routing
        final routeName = settings.name;
        if (routeName != null) {
          if (routeName.startsWith('/book/')) {
            // Navigated to /book/:id
            routeWidget = customScreen(
              routeName.substring(routeName.indexOf('/book/')),
            );
          } else if (routeName == '/book') {
            // Navigated to /book without other parameters
            routeWidget = customScreen("None");
          }
        }

        return MaterialPageRoute(
          builder: (context) => routeWidget,
          settings: settings,
          fullscreenDialog: true,
        );
      },
    );
  }

  Widget defaultScreen() {
    return Scaffold(
      appBar: AppBar(title: const Text('Default Screen')),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const SelectableText('''
            Launch an intent to get to the second screen.

            On web:
            http://localhost:<port>/#/book/1 for example.

            On windows & macOS, open your browser:
            sample://foo/#/book/hello-deep-linking

            This example code triggers new page from URL fragment.
            '''),
            const SizedBox(height: 20),
            buildWindowsUnregisterBtn(),
          ],
        ),
      ),
    );
  }

  Widget customScreen(String bookId) {
    return Scaffold(
      appBar: AppBar(title: const Text('Second Screen')),
      body: Center(child: Text('Opened with parameter: $bookId')),
    );
  }

  Widget buildWindowsUnregisterBtn() {
    if (defaultTargetPlatform == TargetPlatform.windows) {
      return TextButton(
          onPressed: () => unregisterProtocolHandler(kWindowsScheme),
          child: const Text('Remove Windows protocol registration'));
    }

    return const SizedBox.shrink();
  }
}
import 'dart:async';
import 'package:app_links_platform_interface/app_links_platform_interface.dart';

/// App links handler.
///
/// This class is a singleton and should be accessed using `AppLinks()`.
class AppLinks extends AppLinksPlatform {
  static final AppLinks _instance = AppLinks._();

  factory AppLinks() => _instance;

  AppLinks._();

  StreamController<String>? _stringStreamController;
  StreamController<Uri>? _uriStreamController;

  @override
  Future<Uri?> getInitialLink() {
    return AppLinksPlatform.instance.getInitialLink();
  }

  @override
  Future<String?> getInitialLinkString() {
    return AppLinksPlatform.instance.getInitialLinkString();
  }

  @override
  Future<Uri?> getLatestLink() {
    return AppLinksPlatform.instance.getLatestLink();
  }

  @override
  Future<String?> getLatestLinkString() {
    return AppLinksPlatform.instance.getLatestLinkString();
  }

  @override
  Stream<String> get stringLinkStream {
    if (_stringStreamController == null) {
      _stringStreamController = StreamController.broadcast();

      _initController<String>(
        _stringStreamController!,
        AppLinksPlatform.instance.stringLinkStream,
        onCancel: () => _stringStreamController = null,
      );
    }

    return _stringStreamController!.stream;
  }

  @override
  Stream<Uri> get uriLinkStream {
    if (_uriStreamController == null) {
      _uriStreamController = StreamController.broadcast();

      _initController<Uri>(
        _uriStreamController!,
        AppLinksPlatform.instance.uriLinkStream,
        onCancel: () => _uriStreamController = null,
      );
    }

    return _uriStreamController!.stream;
  }

  void _initController<T>(
    StreamController<T> controller,
    Stream<T> stream, {
    required void Function() onCancel,
  }) {
    final subscription = stream.listen(
      controller.add,
      onError: controller.addError,
    );

    // Broadcast controller doesn't support pause/resume
    //
    // Forward cancel event when there's no more listeners
    // and dispose controller
    controller.onCancel = () async {
      await subscription.cancel();
      await controller.close();
      onCancel();
    };
  }
}
export 'src/app_links.dart';
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a directory using `getDirectoryPath`,
///  then displays the selected directory in a dialog.
class GetDirectoryPage extends StatelessWidget {
  /// Default Constructor
  const GetDirectoryPage({super.key});

  Future<void> _getDirectoryPath(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final String? directoryPath =
        await FileSelectorPlatform.instance.getDirectoryPath(
      confirmButtonText: confirmButtonText,
    );
    if (directoryPath == null) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(directoryPath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to ask user to choose a directory'),
              onPressed: () => _getDirectoryPath(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPath, {super.key});

  /// The path selected in the dialog.
  final String directoryPath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directory'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPath),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select one or more directories using `getDirectoryPaths`,
/// then displays the selected directories in a dialog.
class GetMultipleDirectoriesPage extends StatelessWidget {
  /// Default Constructor
  const GetMultipleDirectoriesPage({super.key});

  Future<void> _getDirectoryPaths(BuildContext context) async {
    const String confirmButtonText = 'Choose';
    final List<String?> directoriesPaths =
        await FileSelectorPlatform.instance.getDirectoryPaths(
      confirmButtonText: confirmButtonText,
    );
    if (directoriesPaths.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) =>
            TextDisplay(directoriesPaths.join('\n')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Select multiple directories'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text(
                  'Press to ask user to choose multiple directories'),
              onPressed: () => _getDirectoryPaths(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Creates a `TextDisplay`.
  const TextDisplay(this.directoryPaths, {super.key});

  /// The paths selected in the dialog.
  final String directoryPaths;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Selected Directories'),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(directoryPaths),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Home Page of the application.
class HomePage extends StatelessWidget {
  /// Default Constructor
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final ButtonStyle style = ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
    );
    return Scaffold(
      appBar: AppBar(
        title: const Text('File Selector Demo Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: style,
              child: const Text('Open a text file'),
              onPressed: () => Navigator.pushNamed(context, '/open/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open an image'),
              onPressed: () => Navigator.pushNamed(context, '/open/image'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open multiple images'),
              onPressed: () => Navigator.pushNamed(context, '/open/images'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Save a file'),
              onPressed: () => Navigator.pushNamed(context, '/save/text'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directory dialog'),
              onPressed: () => Navigator.pushNamed(context, '/directory'),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: style,
              child: const Text('Open a get directories dialog'),
              onPressed: () =>
                  Navigator.pushNamed(context, '/multi-directories'),
            ),
          ],
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

import 'get_directory_page.dart';
import 'get_multiple_directories_page.dart';
import 'home_page.dart';
import 'open_image_page.dart';
import 'open_multiple_images_page.dart';
import 'open_text_page.dart';
import 'save_text_page.dart';

void main() {
  runApp(const MyApp());
}

/// MyApp is the Main Application.
class MyApp extends StatelessWidget {
  /// Default Constructor
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'File Selector Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: const HomePage(),
      routes: <String, WidgetBuilder>{
        '/open/image': (BuildContext context) => const OpenImagePage(),
        '/open/images': (BuildContext context) =>
            const OpenMultipleImagesPage(),
        '/open/text': (BuildContext context) => const OpenTextPage(),
        '/save/text': (BuildContext context) => SaveTextPage(),
        '/directory': (BuildContext context) => const GetDirectoryPage(),
        '/multi-directories': (BuildContext context) =>
            const GetMultipleDirectoriesPage()
      },
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select an image file using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenImagePage extends StatelessWidget {
  /// Default Constructor
  const OpenImagePage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'images',
      extensions: <String>['jpg', 'png'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String filePath = file.path;

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => ImageDisplay(fileName, filePath),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open an image'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open an image file(png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays an image in a dialog.
class ImageDisplay extends StatelessWidget {
  /// Default Constructor.
  const ImageDisplay(this.fileName, this.filePath, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The path to the selected file.
  final String filePath;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: kIsWeb ? Image.network(filePath) : Image.file(File(filePath)),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select multiple image files using
/// `openFiles`, then displays the selected images in a gallery dialog.
class OpenMultipleImagesPage extends StatelessWidget {
  /// Default Constructor
  const OpenMultipleImagesPage({super.key});

  Future<void> _openImageFile(BuildContext context) async {
    const XTypeGroup jpgsTypeGroup = XTypeGroup(
      label: 'JPEGs',
      extensions: <String>['jpg', 'jpeg'],
    );
    const XTypeGroup pngTypeGroup = XTypeGroup(
      label: 'PNGs',
      extensions: <String>['png'],
    );
    final List<XFile> files = await FileSelectorPlatform.instance
        .openFiles(acceptedTypeGroups: <XTypeGroup>[
      jpgsTypeGroup,
      pngTypeGroup,
    ]);
    if (files.isEmpty) {
      // Operation was canceled by the user.
      return;
    }
    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => MultipleImagesDisplay(files),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open multiple images'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open multiple images (png, jpg)'),
              onPressed: () => _openImageFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class MultipleImagesDisplay extends StatelessWidget {
  /// Default Constructor.
  const MultipleImagesDisplay(this.files, {super.key});

  /// The files containing the images.
  final List<XFile> files;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('Gallery'),
      // On web the filePath is a blob url
      // while on other platforms it is a system path.
      content: Center(
        child: Row(
          children: <Widget>[
            ...files.map(
              (XFile file) => Flexible(
                  child: kIsWeb
                      ? Image.network(file.path)
                      : Image.file(File(file.path))),
            )
          ],
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () {
            Navigator.pop(context);
          },
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a text file using `openFile`, then
/// displays its contents in a dialog.
class OpenTextPage extends StatelessWidget {
  /// Default Constructor
  const OpenTextPage({super.key});

  Future<void> _openTextFile(BuildContext context) async {
    const XTypeGroup typeGroup = XTypeGroup(
      label: 'text',
      extensions: <String>['txt', 'json'],
    );
    final XFile? file = await FileSelectorPlatform.instance
        .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    if (file == null) {
      // Operation was canceled by the user.
      return;
    }
    final String fileName = file.name;
    final String fileContent = await file.readAsString();

    if (context.mounted) {
      await showDialog<void>(
        context: context,
        builder: (BuildContext context) => TextDisplay(fileName, fileContent),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Open a text file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('Press to open a text file (json, txt)'),
              onPressed: () => _openTextFile(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget that displays a text file in a dialog.
class TextDisplay extends StatelessWidget {
  /// Default Constructor.
  const TextDisplay(this.fileName, this.fileContent, {super.key});

  /// The name of the selected file.
  final String fileName;

  /// The contents of the text file.
  final String fileContent;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(fileName),
      content: Scrollbar(
        child: SingleChildScrollView(
          child: Text(fileContent),
        ),
      ),
      actions: <Widget>[
        TextButton(
          child: const Text('Close'),
          onPressed: () => Navigator.pop(context),
        ),
      ],
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'dart:typed_data';
import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter/material.dart';

/// Screen that allows the user to select a save location using `getSavePath`,
/// then writes text to a file at that location.
class SaveTextPage extends StatelessWidget {
  /// Default Constructor
  SaveTextPage({super.key});

  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _contentController = TextEditingController();

  Future<void> _saveFile() async {
    final String fileName = _nameController.text;
    final FileSaveLocation? result =
        await FileSelectorPlatform.instance.getSaveLocation(
      options: SaveDialogOptions(suggestedName: fileName),
      acceptedTypeGroups: const <XTypeGroup>[
        XTypeGroup(
          label: 'Plain text',
          extensions: <String>['txt'],
        ),
        XTypeGroup(
          label: 'JSON',
          extensions: <String>['json'],
        ),
      ],
    );
    // Operation was canceled by the user.
    if (result == null) {
      return;
    }
    String path = result.path;
    // Append an extension based on the selected type group if the user didn't
    // include one.
    if (!path.split(Platform.pathSeparator).last.contains('.')) {
      final XTypeGroup? activeGroup = result.activeFilter;
      if (activeGroup != null) {
        // The group is one of the groups passed in above, each of which has
        // exactly one `extensions` entry.
        path = '$path.${activeGroup.extensions!.first}';
      }
    }
    final String text = _contentController.text;
    final Uint8List fileData = Uint8List.fromList(text.codeUnits);
    final XFile textFile = XFile.fromData(fileData, name: fileName);
    await textFile.saveTo(result.path);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Save text into a file'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _nameController,
                decoration: const InputDecoration(
                  hintText: '(Optional) Suggest File Name',
                ),
              ),
            ),
            SizedBox(
              width: 300,
              child: TextField(
                minLines: 1,
                maxLines: 12,
                controller: _contentController,
                decoration: const InputDecoration(
                  hintText: 'Enter File Contents',
                ),
              ),
            ),
            const SizedBox(height: 10),
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              onPressed: _saveFile,
              child: const Text('Press to save a text file'),
            ),
          ],
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

class TypeGroup {
  TypeGroup({
    required this.label,
    required this.extensions,
  });

  String label;

  List<String> extensions;

  Object encode() {
    return <Object?>[
      label,
      extensions,
    ];
  }

  static TypeGroup decode(Object result) {
    result as List<Object?>;
    return TypeGroup(
      label: result[0]! as String,
      extensions: (result[1] as List<Object?>?)!.cast<String>(),
    );
  }
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });

  bool allowMultiple;

  bool selectFolders;

  List<TypeGroup> allowedTypes;

  Object encode() {
    return <Object?>[
      allowMultiple,
      selectFolders,
      allowedTypes,
    ];
  }

  static SelectionOptions decode(Object result) {
    result as List<Object?>;
    return SelectionOptions(
      allowMultiple: result[0]! as bool,
      selectFolders: result[1]! as bool,
      allowedTypes: (result[2] as List<Object?>?)!.cast<TypeGroup>(),
    );
  }
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({
    required this.paths,
    this.typeGroupIndex,
  });

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;

  Object encode() {
    return <Object?>[
      paths,
      typeGroupIndex,
    ];
  }

  static FileDialogResult decode(Object result) {
    result as List<Object?>;
    return FileDialogResult(
      paths: (result[0] as List<Object?>?)!.cast<String>(),
      typeGroupIndex: result[1] as int?,
    );
  }
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FileSelectorApi {
  /// Constructor for [FileSelectorApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FileSelectorApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<FileDialogResult> showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[options, initialDirectory, confirmButtonText])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }

  Future<FileDialogResult> showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[
      options,
      initialDirectory,
      suggestedName,
      confirmButtonText
    ]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FileDialogResult?)!;
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [FileSelectorPlatform] for Windows.
class FileSelectorWindows extends FileSelectorPlatform {
  final FileSelectorApi _hostApi = FileSelectorApi();

  /// Registers the Windows implementation.
  static void registerWith() {
    FileSelectorPlatform.instance = FileSelectorWindows();
  }

  @override
  Future<XFile?> openFile({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : XFile(result.paths.first);
  }

  @override
  Future<List<XFile>> openFiles({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.map((String? path) => XFile(path!)).toList();
  }

  @override
  Future<String?> getSavePath({
    List<XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) async {
    final FileSaveLocation? location = await getSaveLocation(
        acceptedTypeGroups: acceptedTypeGroups,
        options: SaveDialogOptions(
          initialDirectory: initialDirectory,
          suggestedName: suggestedName,
          confirmButtonText: confirmButtonText,
        ));
    return location?.path;
  }

  @override
  Future<FileSaveLocation?> getSaveLocation({
    List<XTypeGroup>? acceptedTypeGroups,
    SaveDialogOptions options = const SaveDialogOptions(),
  }) async {
    final FileDialogResult result = await _hostApi.showSaveDialog(
        SelectionOptions(
          allowedTypes: _typeGroupsFromXTypeGroups(acceptedTypeGroups),
        ),
        options.initialDirectory,
        options.suggestedName,
        options.confirmButtonText);
    final int? groupIndex = result.typeGroupIndex;
    return result.paths.isEmpty
        ? null
        : FileSaveLocation(result.paths.first,
            activeFilter:
                groupIndex == null ? null : acceptedTypeGroups?[groupIndex]);
  }

  @override
  Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? null : result.paths.first;
  }

  @override
  Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) async {
    final FileDialogResult result = await _hostApi.showOpenDialog(
        SelectionOptions(
          allowMultiple: true,
          selectFolders: true,
          allowedTypes: <TypeGroup>[],
        ),
        initialDirectory,
        confirmButtonText);
    return result.paths.isEmpty ? <String>[] : List<String>.from(result.paths);
  }
}

List<TypeGroup> _typeGroupsFromXTypeGroups(List<XTypeGroup>? xtypes) {
  return (xtypes ?? <XTypeGroup>[]).map((XTypeGroup xtype) {
    if (!xtype.allowsAny && (xtype.extensions?.isEmpty ?? true)) {
      throw ArgumentError('Provided type group $xtype does not allow '
          'all files, but does not set any of the Windows-supported filter '
          'categories. "extensions" must be non-empty for Windows if '
          'anything is non-empty.');
    }
    return TypeGroup(
        label: xtype.label ?? '', extensions: xtype.extensions ?? <String>[]);
  }).toList();
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  dartTestOut: 'test/test_api.g.dart',
  cppOptions: CppOptions(namespace: 'file_selector_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
class TypeGroup {
  TypeGroup(this.label, {required this.extensions});

  String label;
  List<String> extensions;
}

class SelectionOptions {
  SelectionOptions({
    this.allowMultiple = false,
    this.selectFolders = false,
    this.allowedTypes = const <TypeGroup>[],
  });
  bool allowMultiple;
  bool selectFolders;
  List<TypeGroup> allowedTypes;
}

/// The result from an open or save dialog.
class FileDialogResult {
  FileDialogResult({required this.paths, this.typeGroupIndex});

  /// The selected paths.
  ///
  /// Empty if the dialog was canceled.
  List<String> paths;

  /// The type group index (into the list provided in [SelectionOptions]) of
  /// the group that was selected when the dialog was confirmed.
  ///
  /// Null if no type groups were provided, or the dialog was canceled.
  int? typeGroupIndex;
}

@HostApi(dartHostTestHandler: 'TestFileSelectorApi')
abstract class FileSelectorApi {
  FileDialogResult showOpenDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? confirmButtonText,
  );
  FileDialogResult showSaveDialog(
    SelectionOptions options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  );
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:file_selector_windows/src/messages.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'file_selector_windows_test.mocks.dart';
import 'test_api.g.dart';

@GenerateMocks(<Type>[TestFileSelectorApi])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  final FileSelectorWindows plugin = FileSelectorWindows();
  late MockTestFileSelectorApi mockApi;

  setUp(() {
    mockApi = MockTestFileSelectorApi();
    TestFileSelectorApi.setUp(mockApi);
  });

  test('registered instance', () {
    FileSelectorWindows.registerWith();
    expect(FileSelectorPlatform.instance, isA<FileSelectorWindows>());
  });

  group('openFile', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final XFile? file = await plugin.openFile();

      expect(file!.path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFile(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFile(confirmButtonText: 'Open File');

      verify(mockApi.showOpenDialog(any, null, 'Open File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFile(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('openFiles', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<XFile> file = await plugin.openFiles();

      expect(file[0].path, 'foo');
      expect(file[1].path, 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.openFiles(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.openFiles(confirmButtonText: 'Open Files');

      verify(mockApi.showOpenDialog(any, null, 'Open Files'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.openFiles(acceptedTypeGroups: <XTypeGroup>[group]), completes);
    });
  });

  group('getDirectoryPath', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getDirectoryPath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getDirectoryPaths', () {
    setUp(() {
      when(mockApi.showOpenDialog(any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo', 'bar']));
    });

    test('simple call works', () async {
      final List<String> paths = await plugin.getDirectoryPaths();

      expect(paths[0], 'foo');
      expect(paths[1], 'bar');
      final VerificationResult result =
          verify(mockApi.showOpenDialog(captureAny, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, true);
      expect(options.selectFolders, true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getDirectoryPath(initialDirectory: '/example/directory');

      verify(mockApi.showOpenDialog(any, '/example/directory', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getDirectoryPath(confirmButtonText: 'Open Directory');

      verify(mockApi.showOpenDialog(any, null, 'Open Directory'));
    });
  });

  group('getSaveLocation', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final FileSaveLocation? location = await plugin.getSaveLocation();

      expect(location?.path, 'foo');
      expect(location?.activeFilter, null);
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('returns the selected type group correctly', () async {
      when(mockApi.showSaveDialog(any, any, any, any)).thenReturn(
          FileDialogResult(paths: <String>['foo'], typeGroupIndex: 1));
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      final FileSaveLocation? result = await plugin
          .getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      verify(mockApi.showSaveDialog(captureAny, null, null, null));

      expect(result?.activeFilter, groupTwo);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSaveLocation(
          options:
              const SaveDialogOptions(initialDirectory: '/example/directory'));

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(suggestedName: 'baz.txt'));

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSaveLocation(
          options: const SaveDialogOptions(confirmButtonText: 'Save File'));

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSaveLocation(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });

  group('getSavePath (deprecated)', () {
    setUp(() {
      when(mockApi.showSaveDialog(any, any, any, any))
          .thenReturn(FileDialogResult(paths: <String>['foo']));
    });

    test('simple call works', () async {
      final String? path = await plugin.getSavePath();

      expect(path, 'foo');
      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(options.allowMultiple, false);
      expect(options.selectFolders, false);
    });

    test('passes the accepted type groups correctly', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        extensions: <String>['txt'],
        mimeTypes: <String>['text/plain'],
      );

      const XTypeGroup groupTwo = XTypeGroup(
        label: 'image',
        extensions: <String>['jpg'],
        mimeTypes: <String>['image/jpg'],
      );

      await plugin
          .getSavePath(acceptedTypeGroups: <XTypeGroup>[group, groupTwo]);

      final VerificationResult result =
          verify(mockApi.showSaveDialog(captureAny, null, null, null));
      final SelectionOptions options = result.captured[0] as SelectionOptions;
      expect(
          _typeGroupListsMatch(options.allowedTypes, <TypeGroup>[
            TypeGroup(label: 'text', extensions: <String>['txt']),
            TypeGroup(label: 'image', extensions: <String>['jpg']),
          ]),
          true);
    });

    test('passes initialDirectory correctly', () async {
      await plugin.getSavePath(initialDirectory: '/example/directory');

      verify(mockApi.showSaveDialog(any, '/example/directory', null, null));
    });

    test('passes suggestedName correctly', () async {
      await plugin.getSavePath(suggestedName: 'baz.txt');

      verify(mockApi.showSaveDialog(any, null, 'baz.txt', null));
    });

    test('passes confirmButtonText correctly', () async {
      await plugin.getSavePath(confirmButtonText: 'Save File');

      verify(mockApi.showSaveDialog(any, null, null, 'Save File'));
    });

    test('throws for a type group that does not support Windows', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
        mimeTypes: <String>['text/plain'],
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          throwsArgumentError);
    });

    test('allows a wildcard group', () async {
      const XTypeGroup group = XTypeGroup(
        label: 'text',
      );

      await expectLater(
          plugin.getSavePath(acceptedTypeGroups: <XTypeGroup>[group]),
          completes);
    });
  });
}

// True if the given options match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupListsMatch(List<TypeGroup?> a, List<TypeGroup?> b) {
  if (a.length != b.length) {
    return false;
  }
  for (int i = 0; i < a.length; i++) {
    if (!_typeGroupsMatch(a[i], b[i])) {
      return false;
    }
  }
  return true;
}

// True if the given type groups match.
//
// This is needed because Pigeon data classes don't have custom equality checks,
// so only match for identical instances.
bool _typeGroupsMatch(TypeGroup? a, TypeGroup? b) {
  return a!.label == b!.label && listEquals(a.extensions, b.extensions);
}
// Mocks generated by Mockito 5.4.4 from annotations
// in file_selector_windows/test/file_selector_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:file_selector_windows/src/messages.g.dart' as _i2;
import 'package:mockito/mockito.dart' as _i1;

import 'test_api.g.dart' as _i3;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeFileDialogResult_0 extends _i1.SmartFake
    implements _i2.FileDialogResult {
  _FakeFileDialogResult_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [TestFileSelectorApi].
///
/// See the documentation for Mockito's code generation for more information.
class MockTestFileSelectorApi extends _i1.Mock
    implements _i3.TestFileSelectorApi {
  MockTestFileSelectorApi() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.FileDialogResult showOpenDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showOpenDialog,
          [
            options,
            initialDirectory,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showOpenDialog,
            [
              options,
              initialDirectory,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);

  @override
  _i2.FileDialogResult showSaveDialog(
    _i2.SelectionOptions? options,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #showSaveDialog,
          [
            options,
            initialDirectory,
            suggestedName,
            confirmButtonText,
          ],
        ),
        returnValue: _FakeFileDialogResult_0(
          this,
          Invocation.method(
            #showSaveDialog,
            [
              options,
              initialDirectory,
              suggestedName,
              confirmButtonText,
            ],
          ),
        ),
      ) as _i2.FileDialogResult);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.4.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, unnecessary_import, no_leading_underscores_for_local_identifiers
// ignore_for_file: avoid_relative_lib_imports
import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;
import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:file_selector_windows/src/messages.g.dart';

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is TypeGroup) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is SelectionOptions) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is FileDialogResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        return TypeGroup.decode(readValue(buffer)!);
      case 130:
        return SelectionOptions.decode(readValue(buffer)!);
      case 131:
        return FileDialogResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class TestFileSelectorApi {
  static TestDefaultBinaryMessengerBinding? get _testBinaryMessengerBinding =>
      TestDefaultBinaryMessengerBinding.instance;
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  FileDialogResult showOpenDialog(SelectionOptions options,
      String? initialDirectory, String? confirmButtonText);

  FileDialogResult showSaveDialog(
      SelectionOptions options,
      String? initialDirectory,
      String? suggestedName,
      String? confirmButtonText);

  static void setUp(
    TestFileSelectorApi? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showOpenDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_confirmButtonText = (args[2] as String?);
          try {
            final FileDialogResult output = api.showOpenDialog(
                arg_options!, arg_initialDirectory, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel, null);
      } else {
        _testBinaryMessengerBinding!.defaultBinaryMessenger
            .setMockDecodedMessageHandler<Object?>(pigeonVar_channel,
                (Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final SelectionOptions? arg_options = (args[0] as SelectionOptions?);
          assert(arg_options != null,
              'Argument for dev.flutter.pigeon.file_selector_windows.FileSelectorApi.showSaveDialog was null, expected non-null SelectionOptions.');
          final String? arg_initialDirectory = (args[1] as String?);
          final String? arg_suggestedName = (args[2] as String?);
          final String? arg_confirmButtonText = (args[3] as String?);
          try {
            final FileDialogResult output = api.showSaveDialog(arg_options!,
                arg_initialDirectory, arg_suggestedName, arg_confirmButtonText);
            return <Object?>[output];
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:mime/mime.dart';
import 'package:video_player/video_player.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Image Picker Demo',
      home: MyHomePage(title: 'Image Picker Example'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, this.title});

  final String? title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<XFile>? _mediaFileList;

  // This must be called from within a setState() callback
  void _setImageFileListFromFile(XFile? value) {
    _mediaFileList = value == null ? null : <XFile>[value];
  }

  dynamic _pickImageError;
  bool _isVideo = false;

  VideoPlayerController? _controller;
  VideoPlayerController? _toBeDisposed;
  String? _retrieveDataError;

  final ImagePickerPlatform _picker = ImagePickerPlatform.instance;
  final TextEditingController maxWidthController = TextEditingController();
  final TextEditingController maxHeightController = TextEditingController();
  final TextEditingController qualityController = TextEditingController();

  Future<void> _playVideo(XFile? file) async {
    if (file != null && mounted) {
      await _disposeVideoController();
      final VideoPlayerController controller =
          VideoPlayerController.file(File(file.path));
      _controller = controller;
      await controller.setVolume(1.0);
      await controller.initialize();
      await controller.setLooping(true);
      await controller.play();
      setState(() {});
    }
  }

  Future<void> _onImageButtonPressed(
    ImageSource source, {
    required BuildContext context,
    bool isMultiImage = false,
    bool isMedia = false,
  }) async {
    if (_controller != null) {
      await _controller!.setVolume(0.0);
    }
    if (context.mounted) {
      if (_isVideo) {
        final XFile? file = await _picker.getVideo(
            source: source, maxDuration: const Duration(seconds: 10));
        await _playVideo(file);
      } else if (isMultiImage) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = isMedia
                ? await _picker.getMedia(
                    options: MediaOptions(
                        allowMultiple: isMultiImage,
                        imageOptions: ImageOptions(
                          maxWidth: maxWidth,
                          maxHeight: maxHeight,
                          imageQuality: quality,
                        )),
                  )
                : await _picker.getMultiImageWithOptions(
                    options: MultiImagePickerOptions(
                      imageOptions: ImageOptions(
                        maxWidth: maxWidth,
                        maxHeight: maxHeight,
                        imageQuality: quality,
                      ),
                    ),
                  );
            setState(() {
              _mediaFileList = pickedFileList;
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      } else if (isMedia) {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final List<XFile> pickedFileList = <XFile>[];
            final XFile? media = _firstOrNull(await _picker.getMedia(
              options: MediaOptions(
                  allowMultiple: isMultiImage,
                  imageOptions: ImageOptions(
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    imageQuality: quality,
                  )),
            ));

            if (media != null) {
              pickedFileList.add(media);
              setState(() {
                _mediaFileList = pickedFileList;
              });
            }
          } catch (e) {
            setState(() => _pickImageError = e);
          }
        });
      } else {
        await _displayPickImageDialog(context,
            (double? maxWidth, double? maxHeight, int? quality) async {
          try {
            final XFile? pickedFile = await _picker.getImageFromSource(
              source: source,
              options: ImagePickerOptions(
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                imageQuality: quality,
              ),
            );
            setState(() {
              _setImageFileListFromFile(pickedFile);
            });
          } catch (e) {
            setState(() {
              _pickImageError = e;
            });
          }
        });
      }
    }
  }

  @override
  void deactivate() {
    if (_controller != null) {
      _controller!.setVolume(0.0);
      _controller!.pause();
    }
    super.deactivate();
  }

  @override
  void dispose() {
    _disposeVideoController();
    maxWidthController.dispose();
    maxHeightController.dispose();
    qualityController.dispose();
    super.dispose();
  }

  Future<void> _disposeVideoController() async {
    if (_toBeDisposed != null) {
      await _toBeDisposed!.dispose();
    }
    _toBeDisposed = _controller;
    _controller = null;
  }

  Widget _previewVideo() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_controller == null) {
      return const Text(
        'You have not yet picked a video',
        textAlign: TextAlign.center,
      );
    }
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: AspectRatioVideo(_controller),
    );
  }

  Widget _previewImages() {
    final Text? retrieveError = _getRetrieveErrorWidget();
    if (retrieveError != null) {
      return retrieveError;
    }
    if (_mediaFileList != null) {
      return Semantics(
        label: 'image_picker_example_picked_images',
        child: ListView.builder(
          key: UniqueKey(),
          itemBuilder: (BuildContext context, int index) {
            final String? mime = lookupMimeType(_mediaFileList![index].path);
            return Semantics(
              label: 'image_picker_example_picked_image',
              child: mime == null || mime.startsWith('image/')
                  ? Image.file(
                      File(_mediaFileList![index].path),
                      errorBuilder: (BuildContext context, Object error,
                          StackTrace? stackTrace) {
                        return const Center(
                            child: Text('This image type is not supported'));
                      },
                    )
                  : _buildInlineVideoPlayer(index),
            );
          },
          itemCount: _mediaFileList!.length,
        ),
      );
    } else if (_pickImageError != null) {
      return Text(
        'Pick image error: $_pickImageError',
        textAlign: TextAlign.center,
      );
    } else {
      return const Text(
        'You have not yet picked an image.',
        textAlign: TextAlign.center,
      );
    }
  }

  Widget _buildInlineVideoPlayer(int index) {
    final VideoPlayerController controller =
        VideoPlayerController.file(File(_mediaFileList![index].path));
    const double volume = 1.0;
    controller.setVolume(volume);
    controller.initialize();
    controller.setLooping(true);
    controller.play();
    return Center(child: AspectRatioVideo(controller));
  }

  Widget _handlePreview() {
    if (_isVideo) {
      return _previewVideo();
    } else {
      return _previewImages();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title!),
      ),
      body: Center(
        child: _handlePreview(),
      ),
      floatingActionButton: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: <Widget>[
          Semantics(
            label: 'image_picker_example_from_gallery',
            child: FloatingActionButton(
              key: const Key('image_picker_example_from_gallery'),
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'image0',
              tooltip: 'Pick Image from gallery',
              child: const Icon(Icons.photo),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMultiImage: true,
                  isMedia: true,
                );
              },
              heroTag: 'multipleMedia',
              tooltip: 'Pick Multiple Media from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMedia: true,
                );
              },
              heroTag: 'media',
              tooltip: 'Pick Single Media from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              onPressed: () {
                _isVideo = false;
                _onImageButtonPressed(
                  ImageSource.gallery,
                  context: context,
                  isMultiImage: true,
                );
              },
              heroTag: 'image1',
              tooltip: 'Pick Multiple Image from gallery',
              child: const Icon(Icons.photo_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton(
                onPressed: () {
                  _isVideo = false;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'image2',
                tooltip: 'Take a Photo',
                child: const Icon(Icons.camera_alt),
              ),
            ),
          Padding(
            padding: const EdgeInsets.only(top: 16.0),
            child: FloatingActionButton(
              backgroundColor: Colors.red,
              onPressed: () {
                _isVideo = true;
                _onImageButtonPressed(ImageSource.gallery, context: context);
              },
              heroTag: 'video0',
              tooltip: 'Pick Video from gallery',
              child: const Icon(Icons.video_library),
            ),
          ),
          if (_picker.supportsImageSource(ImageSource.camera))
            Padding(
              padding: const EdgeInsets.only(top: 16.0),
              child: FloatingActionButton(
                backgroundColor: Colors.red,
                onPressed: () {
                  _isVideo = true;
                  _onImageButtonPressed(ImageSource.camera, context: context);
                },
                heroTag: 'video1',
                tooltip: 'Take a Video',
                child: const Icon(Icons.videocam),
              ),
            ),
        ],
      ),
    );
  }

  Text? _getRetrieveErrorWidget() {
    if (_retrieveDataError != null) {
      final Text result = Text(_retrieveDataError!);
      _retrieveDataError = null;
      return result;
    }
    return null;
  }

  Future<void> _displayPickImageDialog(
      BuildContext context, OnPickImageCallback onPick) async {
    return showDialog(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: const Text('Add optional parameters'),
            content: Column(
              children: <Widget>[
                TextField(
                  controller: maxWidthController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxWidth if desired'),
                ),
                TextField(
                  controller: maxHeightController,
                  keyboardType:
                      const TextInputType.numberWithOptions(decimal: true),
                  decoration: const InputDecoration(
                      hintText: 'Enter maxHeight if desired'),
                ),
                TextField(
                  controller: qualityController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                      hintText: 'Enter quality if desired'),
                ),
              ],
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('CANCEL'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                  child: const Text('PICK'),
                  onPressed: () {
                    final double? width = maxWidthController.text.isNotEmpty
                        ? double.parse(maxWidthController.text)
                        : null;
                    final double? height = maxHeightController.text.isNotEmpty
                        ? double.parse(maxHeightController.text)
                        : null;
                    final int? quality = qualityController.text.isNotEmpty
                        ? int.parse(qualityController.text)
                        : null;
                    onPick(width, height, quality);
                    Navigator.of(context).pop();
                  }),
            ],
          );
        });
  }
}

typedef OnPickImageCallback = void Function(
    double? maxWidth, double? maxHeight, int? quality);

class AspectRatioVideo extends StatefulWidget {
  const AspectRatioVideo(this.controller, {super.key});

  final VideoPlayerController? controller;

  @override
  AspectRatioVideoState createState() => AspectRatioVideoState();
}

class AspectRatioVideoState extends State<AspectRatioVideo> {
  VideoPlayerController? get controller => widget.controller;
  bool initialized = false;

  void _onVideoControllerUpdate() {
    if (!mounted) {
      return;
    }
    if (initialized != controller!.value.isInitialized) {
      initialized = controller!.value.isInitialized;
      setState(() {});
    }
  }

  @override
  void initState() {
    super.initState();
    controller!.addListener(_onVideoControllerUpdate);
  }

  @override
  void dispose() {
    controller!.removeListener(_onVideoControllerUpdate);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (initialized) {
      return Center(
        child: AspectRatio(
          aspectRatio: controller!.value.aspectRatio,
          child: VideoPlayer(controller!),
        ),
      );
    } else {
      return Container();
    }
  }
}

T? _firstOrNull<T>(List<T> list) {
  return list.isEmpty ? null : list.first;
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:file_selector_windows/file_selector_windows.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';

/// The Windows implementation of [ImagePickerPlatform].
///
/// This class implements the `package:image_picker` functionality for
/// Windows.
class ImagePickerWindows extends CameraDelegatingImagePickerPlatform {
  /// Constructs a ImagePickerWindows.
  ImagePickerWindows();

  /// List of image extensions used when picking images
  @visibleForTesting
  static const List<String> imageFormats = <String>[
    'jpg',
    'jpeg',
    'png',
    'bmp',
    'webp',
    'gif',
    'tif',
    'tiff',
    'apng'
  ];

  /// List of video extensions used when picking videos
  @visibleForTesting
  static const List<String> videoFormats = <String>[
    'mov',
    'wmv',
    'mkv',
    'mp4',
    'webm',
    'avi',
    'mpeg',
    'mpg'
  ];

  /// The file selector used to prompt the user to select images or videos.
  @visibleForTesting
  static FileSelectorPlatform fileSelector = FileSelectorWindows();

  /// Registers this class as the default instance of [ImagePickerPlatform].
  static void registerWith() {
    ImagePickerPlatform.instance = ImagePickerWindows();
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<PickedFile?> pickImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    final XFile? file = await getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getVideo.
  @override
  Future<PickedFile?> pickVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    final XFile? file = await getVideo(
        source: source,
        preferredCameraDevice: preferredCameraDevice,
        maxDuration: maxDuration);
    if (file != null) {
      return PickedFile(file.path);
    }
    return null;
  }

  // This is soft-deprecated in the platform interface, and is only implemented
  // for compatibility. Callers should be using getImageFromSource.
  @override
  Future<XFile?> getImage({
    required ImageSource source,
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
  }) async {
    return getImageFromSource(
        source: source,
        options: ImagePickerOptions(
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            imageQuality: imageQuality,
            preferredCameraDevice: preferredCameraDevice));
  }

  // [ImagePickerOptions] options are not currently supported. If any
  // of its fields are set, they will be silently ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getImageFromSource({
    required ImageSource source,
    ImagePickerOptions options = const ImagePickerOptions(),
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getImageFromSource(source: source);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Images', extensions: imageFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `preferredCameraDevice` and `maxDuration` arguments are not currently
  // supported. If either of these arguments are supplied, they will be silently
  // ignored.
  //
  // If source is `ImageSource.camera`, a `StateError` will be thrown
  // unless a [cameraDelegate] is set.
  @override
  Future<XFile?> getVideo({
    required ImageSource source,
    CameraDevice preferredCameraDevice = CameraDevice.rear,
    Duration? maxDuration,
  }) async {
    switch (source) {
      case ImageSource.camera:
        return super.getVideo(
            source: source,
            preferredCameraDevice: preferredCameraDevice,
            maxDuration: maxDuration);
      case ImageSource.gallery:
        const XTypeGroup typeGroup =
            XTypeGroup(label: 'Videos', extensions: videoFormats);
        final XFile? file = await fileSelector
            .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
        return file;
    }
    // Ensure that there's a fallback in case a new source is added.
    // ignore: dead_code
    throw UnimplementedError('Unknown ImageSource: $source');
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not currently
  // supported. If any of these arguments are supplied, they will be silently
  // ignored.
  @override
  Future<List<XFile>> getMultiImage({
    double? maxWidth,
    double? maxHeight,
    int? imageQuality,
  }) async {
    const XTypeGroup typeGroup =
        XTypeGroup(label: 'Images', extensions: imageFormats);
    final List<XFile> files = await fileSelector
        .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    return files;
  }

  // `maxWidth`, `maxHeight`, and `imageQuality` arguments are not
  // supported on Windows. If any of these arguments is supplied,
  // they will be silently ignored by the Windows version of the plugin.
  @override
  Future<List<XFile>> getMedia({required MediaOptions options}) async {
    const XTypeGroup typeGroup = XTypeGroup(
        label: 'images and videos',
        extensions: <String>[...imageFormats, ...videoFormats]);

    List<XFile> files;

    if (options.allowMultiple) {
      files = await fileSelector
          .openFiles(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
    } else {
      final XFile? file = await fileSelector
          .openFile(acceptedTypeGroups: <XTypeGroup>[typeGroup]);
      files = <XFile>[
        if (file != null) file,
      ];
    }
    return files;
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:image_picker_platform_interface/image_picker_platform_interface.dart';
import 'package:image_picker_windows/image_picker_windows.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'image_picker_windows_test.mocks.dart';

@GenerateMocks(<Type>[FileSelectorPlatform])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Returns the captured type groups from a mock call result, assuming that
  // exactly one call was made and only the type groups were captured.
  List<XTypeGroup> capturedTypeGroups(VerificationResult result) {
    return result.captured.single as List<XTypeGroup>;
  }

  group('ImagePickerWindows', () {
    late ImagePickerWindows plugin;
    late MockFileSelectorPlatform mockFileSelectorPlatform;

    setUp(() {
      plugin = ImagePickerWindows();
      mockFileSelectorPlatform = MockFileSelectorPlatform();

      when(mockFileSelectorPlatform.openFile(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => null);

      when(mockFileSelectorPlatform.openFiles(
              acceptedTypeGroups: anyNamed('acceptedTypeGroups')))
          .thenAnswer((_) async => List<XFile>.empty());

      ImagePickerWindows.fileSelector = mockFileSelectorPlatform;
    });

    test('registered instance', () {
      ImagePickerWindows.registerWith();
      expect(ImagePickerPlatform.instance, isA<ImagePickerWindows>());
    });

    group('images', () {
      test('pickImage passes the accepted type groups correctly', () async {
        await plugin.pickImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getImage passes the accepted type groups correctly', () async {
        await plugin.getImage(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });

      test(
          'getImageFromSource throws StateError when source is camera with no delegate',
          () async {
        await expectLater(plugin.getImageFromSource(source: ImageSource.camera),
            throwsStateError);
      });

      test('getMultiImage passes the accepted type groups correctly', () async {
        await plugin.getMultiImage();

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.imageFormats);
      });
    });

    group('videos', () {
      test('pickVideo passes the accepted type groups correctly', () async {
        await plugin.pickVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo passes the accepted type groups correctly', () async {
        await plugin.getVideo(source: ImageSource.gallery);

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFile(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions,
            ImagePickerWindows.videoFormats);
      });

      test('getVideo calls delegate when source is camera', () async {
        const String fakePath = '/tmp/foo';
        plugin.cameraDelegate = FakeCameraDelegate(result: XFile(fakePath));
        expect((await plugin.getVideo(source: ImageSource.camera))!.path,
            fakePath);
      });

      test('getVideo throws StateError when source is camera with no delegate',
          () async {
        await expectLater(
            plugin.getVideo(source: ImageSource.camera), throwsStateError);
      });
    });

    group('media', () {
      test('getMedia passes the accepted type groups correctly', () async {
        await plugin.getMedia(options: const MediaOptions(allowMultiple: true));

        final VerificationResult result = verify(
            mockFileSelectorPlatform.openFiles(
                acceptedTypeGroups: captureAnyNamed('acceptedTypeGroups')));
        expect(capturedTypeGroups(result)[0].extensions, <String>[
          ...ImagePickerWindows.imageFormats,
          ...ImagePickerWindows.videoFormats
        ]);
      });

      test('multiple media handles an empty path response gracefully',
          () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: true,
              ),
            ),
            <String>[]);
      });

      test('single media handles an empty path response gracefully', () async {
        expect(
            await plugin.getMedia(
              options: const MediaOptions(
                allowMultiple: false,
              ),
            ),
            <String>[]);
      });
    });
  });
}

class FakeCameraDelegate extends ImagePickerCameraDelegate {
  FakeCameraDelegate({this.result});

  XFile? result;

  @override
  Future<XFile?> takePhoto(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }

  @override
  Future<XFile?> takeVideo(
      {ImagePickerCameraDelegateOptions options =
          const ImagePickerCameraDelegateOptions()}) async {
    return result;
  }
}
// Mocks generated by Mockito 5.4.0 from annotations
// in image_picker_windows/test/image_picker_windows_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:file_selector_platform_interface/file_selector_platform_interface.dart'
    as _i2;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

/// A class which mocks [FileSelectorPlatform].
///
/// See the documentation for Mockito's code generation for more information.
class MockFileSelectorPlatform extends _i1.Mock
    implements _i2.FileSelectorPlatform {
  MockFileSelectorPlatform() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i2.XFile?> openFile({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFile,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<_i2.XFile?>.value(),
      ) as _i3.Future<_i2.XFile?>);
  @override
  _i3.Future<List<_i2.XFile>> openFiles({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #openFiles,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<_i2.XFile>>.value(<_i2.XFile>[]),
      ) as _i3.Future<List<_i2.XFile>>);
  @override
  _i3.Future<String?> getSavePath({
    List<_i2.XTypeGroup>? acceptedTypeGroups,
    String? initialDirectory,
    String? suggestedName,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSavePath,
          [],
          {
            #acceptedTypeGroups: acceptedTypeGroups,
            #initialDirectory: initialDirectory,
            #suggestedName: suggestedName,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);
  @override
  _i3.Future<String?> getDirectoryPath({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPath,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<String?>.value(),
      ) as _i3.Future<String?>);
  @override
  _i3.Future<List<String>> getDirectoryPaths({
    String? initialDirectory,
    String? confirmButtonText,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getDirectoryPaths,
          [],
          {
            #initialDirectory: initialDirectory,
            #confirmButtonText: confirmButtonText,
          },
        ),
        returnValue: _i3.Future<List<String>>.value(<String>[]),
      ) as _i3.Future<List<String>>);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('getTemporaryDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getTemporaryPath();
    _verifySampleFile(result, 'temporaryDirectory');
  });

  testWidgets('getApplicationDocumentsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationDocumentsPath();
    _verifySampleFile(result, 'applicationDocuments');
  });

  testWidgets('getApplicationSupportDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationSupportPath();
    _verifySampleFile(result, 'applicationSupport');
  });

  testWidgets('getApplicationCacheDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getApplicationCachePath();
    _verifySampleFile(result, 'applicationCache');
  });

  testWidgets('getDownloadsDirectory', (WidgetTester tester) async {
    final PathProviderWindows provider = PathProviderWindows();
    final String? result = await provider.getDownloadsPath();
    _verifySampleFile(result, 'downloads');
  });
}

/// Verify a file called [name] in [directoryPath] by recreating it with test
/// contents when necessary.
void _verifySampleFile(String? directoryPath, String name) {
  expect(directoryPath, isNotNull);
  if (directoryPath == null) {
    return;
  }
  final Directory directory = Directory(directoryPath);
  final File file = File('${directory.path}${Platform.pathSeparator}$name');

  if (file.existsSync()) {
    file.deleteSync();
    expect(file.existsSync(), isFalse);
  }

  file.writeAsStringSync('Hello world!');
  expect(file.readAsStringSync(), 'Hello world!');
  expect(directory.listSync(), isNotEmpty);
  file.deleteSync();
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

void main() {
  runApp(const MyApp());
}

/// Sample app
class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  String? _tempDirectory = 'Unknown';
  String? _downloadsDirectory = 'Unknown';
  String? _appSupportDirectory = 'Unknown';
  String? _documentsDirectory = 'Unknown';
  String? _cacheDirectory = 'Unknown';

  @override
  void initState() {
    super.initState();
    initDirectories();
  }

  // Platform messages are asynchronous, so we initialize in an async method.
  Future<void> initDirectories() async {
    String? tempDirectory;
    String? downloadsDirectory;
    String? appSupportDirectory;
    String? documentsDirectory;
    String? cacheDirectory;
    final PathProviderWindows provider = PathProviderWindows();

    try {
      tempDirectory = await provider.getTemporaryPath();
    } catch (exception) {
      tempDirectory = 'Failed to get temp directory: $exception';
    }
    try {
      downloadsDirectory = await provider.getDownloadsPath();
    } catch (exception) {
      downloadsDirectory = 'Failed to get downloads directory: $exception';
    }

    try {
      documentsDirectory = await provider.getApplicationDocumentsPath();
    } catch (exception) {
      documentsDirectory = 'Failed to get documents directory: $exception';
    }

    try {
      appSupportDirectory = await provider.getApplicationSupportPath();
    } catch (exception) {
      appSupportDirectory = 'Failed to get app support directory: $exception';
    }

    try {
      cacheDirectory = await provider.getApplicationCachePath();
    } catch (exception) {
      cacheDirectory = 'Failed to get cache directory: $exception';
    }

    setState(() {
      _tempDirectory = tempDirectory;
      _downloadsDirectory = downloadsDirectory;
      _appSupportDirectory = appSupportDirectory;
      _documentsDirectory = documentsDirectory;
      _cacheDirectory = cacheDirectory;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Path Provider example app'),
        ),
        body: Center(
          child: Column(
            children: <Widget>[
              Text('Temp Directory: $_tempDirectory\n'),
              Text('Documents Directory: $_documentsDirectory\n'),
              Text('Downloads Directory: $_downloadsDirectory\n'),
              Text('Application Support Directory: $_appSupportDirectory\n'),
              Text('Cache Directory: $_cacheDirectory\n'),
            ],
          ),
        ),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: non_constant_identifier_names

// ignore: avoid_classes_with_only_static_members
/// A class containing the GUID references for each of the documented Windows
/// known folders. A property of this class may be passed to the `getPath`
/// method in the [PathProvidersWindows] class to retrieve a known folder from
/// Windows.
// These constants come from
// https://learn.microsoft.com/windows/win32/shell/knownfolderid
class WindowsKnownFolder {
  /// The file system directory that is used to store administrative tools for
  /// an individual user. The MMC will save customized consoles to this
  /// directory, and it will roam with the user.
  static String get AdminTools => '{724EF170-A42D-4FEF-9F26-B60E846FBA4F}';

  /// The file system directory that acts as a staging area for files waiting to
  /// be written to a CD. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data\Microsoft\CD Burning.
  static String get CDBurning => '{9E52AB10-F80D-49DF-ACB8-4330F5687855}';

  /// The file system directory that contains administrative tools for all users
  /// of the computer.
  static String get CommonAdminTools =>
      '{D0384E7D-BAC3-4797-8F14-CBA229B392B5}';

  /// The file system directory that contains the directories for the common
  /// program groups that appear on the Start menu for all users. A typical path
  /// is C:\Documents and Settings\All Users\Start Menu\Programs.
  static String get CommonPrograms => '{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}';

  /// The file system directory that contains the programs and folders that
  /// appear on the Start menu for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu.
  static String get CommonStartMenu => '{A4115719-D62E-491D-AA7C-E74B8BE3B067}';

  /// The file system directory that contains the programs that appear in the
  /// Startup folder for all users. A typical path is C:\Documents and
  /// Settings\All Users\Start Menu\Programs\Startup.
  static String get CommonStartup => '{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}';

  /// The file system directory that contains the templates that are available
  /// to all users. A typical path is C:\Documents and Settings\All
  /// Users\Templates.
  static String get CommonTemplates => '{B94237E7-57AC-4347-9151-B08C6C32D1F7}';

  /// The virtual folder that represents My Computer, containing everything on
  /// the local computer: storage devices, printers, and Control Panel. The
  /// folder can also contain mapped network drives.
  static String get ComputerFolder => '{0AC0837C-BBF8-452A-850D-79D08E667CA7}';

  /// The virtual folder that represents Network Connections, that contains
  /// network and dial-up connections.
  static String get ConnectionsFolder =>
      '{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}';

  /// The virtual folder that contains icons for the Control Panel applications.
  static String get ControlPanelFolder =>
      '{82A74AEB-AEB4-465C-A014-D097EE346D63}';

  /// The file system directory that serves as a common repository for Internet
  /// cookies. A typical path is C:\Documents and Settings\username\Cookies.
  static String get Cookies => '{2B0F765D-C0E9-4171-908E-08A611B84FF6}';

  /// The virtual folder that represents the Windows desktop, the root of the
  /// namespace.
  static String get Desktop => '{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}';

  /// The virtual folder that represents the My Documents desktop item.
  static String get Documents => '{FDD39AD0-238F-46AF-ADB4-6C85480369C7}';

  /// The file system directory that serves as a repository for Internet
  /// downloads.
  static String get Downloads => '{374DE290-123F-4565-9164-39C4925E467B}';

  /// The file system directory that serves as a common repository for the
  /// user's favorite items. A typical path is C:\Documents and
  /// Settings\username\Favorites.
  static String get Favorites => '{1777F761-68AD-4D8A-87BD-30B759FA33DD}';

  /// A virtual folder that contains fonts. A typical path is C:\Windows\Fonts.
  static String get Fonts => '{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}';

  /// The file system directory that serves as a common repository for Internet
  /// history items.
  static String get History => '{D9DC8A3B-B784-432E-A781-5A1130A75963}';

  /// The file system directory that serves as a common repository for temporary
  /// Internet files. A typical path is C:\Documents and Settings\username\Local
  /// Settings\Temporary Internet Files.
  static String get InternetCache => '{352481E8-33BE-4251-BA85-6007CAEDCF9D}';

  /// A virtual folder for Internet Explorer.
  static String get InternetFolder => '{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}';

  /// The file system directory that serves as a data repository for local
  /// (nonroaming) applications. A typical path is C:\Documents and
  /// Settings\username\Local Settings\Application Data.
  static String get LocalAppData => '{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}';

  /// The file system directory that serves as a common repository for music
  /// files. A typical path is C:\Documents and Settings\User\My Documents\My
  /// Music.
  static String get Music => '{4BD8D571-6D19-48D3-BE97-422220080E43}';

  /// A file system directory that contains the link objects that may exist in
  /// the My Network Places virtual folder. A typical path is C:\Documents and
  /// Settings\username\NetHood.
  static String get NetHood => '{C5ABBF53-E17F-4121-8900-86626FC2C973}';

  /// The folder that represents other computers in your workgroup.
  static String get NetworkFolder => '{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}';

  /// The file system directory that serves as a common repository for image
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Pictures.
  static String get Pictures => '{33E28130-4E1E-4676-835A-98395C3BC3BB}';

  /// The file system directory that contains the link objects that can exist in
  /// the Printers virtual folder. A typical path is C:\Documents and
  /// Settings\username\PrintHood.
  static String get PrintHood => '{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}';

  /// The virtual folder that contains installed printers.
  static String get PrintersFolder => '{76FC4E2D-D6AD-4519-A663-37BD56068185}';

  /// The user's profile folder. A typical path is C:\Users\username.
  /// Applications should not create files or folders at this level.
  static String get Profile => '{5E6C858F-0E22-4760-9AFE-EA3317B67173}';

  /// The file system directory that contains application data for all users. A
  /// typical path is C:\Documents and Settings\All Users\Application Data. This
  /// folder is used for application data that is not user specific. For
  /// example, an application can store a spell-check dictionary, a database of
  /// clip art, or a log file in the CSIDL_COMMON_APPDATA folder. This
  /// information will not roam and is available to anyone using the computer.
  static String get ProgramData => '{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}';

  /// The Program Files folder. A typical path is C:\Program Files.
  static String get ProgramFiles => '{905e63b6-c1bf-494e-b29c-65b732d3d21a}';

  /// The common Program Files folder. A typical path is C:\Program
  /// Files\Common.
  static String get ProgramFilesCommon =>
      '{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}';

  /// On 64-bit systems, a link to the common Program Files folder. A typical path is
  /// C:\Program Files\Common Files.
  static String get ProgramFilesCommonX64 =>
      '{6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}';

  /// On 64-bit systems, a link to the 32-bit common Program Files folder. A
  /// typical path is C:\Program Files (x86)\Common Files. On 32-bit systems, a
  /// link to the Common Program Files folder.
  static String get ProgramFilesCommonX86 =>
      '{DE974D24-D9C6-4D3E-BF91-F4455120B917}';

  /// On 64-bit systems, a link to the Program Files folder. A typical path is
  /// C:\Program Files.
  static String get ProgramFilesX64 => '{6D809377-6AF0-444b-8957-A3773F02200E}';

  /// On 64-bit systems, a link to the 32-bit Program Files folder. A typical
  /// path is C:\Program Files (x86). On 32-bit systems, a link to the Common
  /// Program Files folder.
  static String get ProgramFilesX86 => '{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}';

  /// The file system directory that contains the user's program groups (which
  /// are themselves file system directories).
  static String get Programs => '{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}';

  /// The file system directory that contains files and folders that appear on
  /// the desktop for all users. A typical path is C:\Documents and Settings\All
  /// Users\Desktop.
  static String get PublicDesktop => '{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}';

  /// The file system directory that contains documents that are common to all
  /// users. A typical path is C:\Documents and Settings\All Users\Documents.
  static String get PublicDocuments => '{ED4824AF-DCE4-45A8-81E2-FC7965083634}';

  /// The file system directory that serves as a repository for music files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Music.
  static String get PublicMusic => '{3214FAB5-9757-4298-BB61-92A9DEAA44FF}';

  /// The file system directory that serves as a repository for image files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Pictures.
  static String get PublicPictures => '{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}';

  /// The file system directory that serves as a repository for video files
  /// common to all users. A typical path is C:\Documents and Settings\All
  /// Users\Documents\My Videos.
  static String get PublicVideos => '{2400183A-6185-49FB-A2D8-4A392A602BA3}';

  /// The file system directory that contains shortcuts to the user's most
  /// recently used documents. A typical path is C:\Documents and
  /// Settings\username\My Recent Documents.
  static String get Recent => '{AE50C081-EBD2-438A-8655-8A092E34987A}';

  /// The virtual folder that contains the objects in the user's Recycle Bin.
  static String get RecycleBinFolder =>
      '{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}';

  /// The file system directory that contains resource data. A typical path is
  /// C:\Windows\Resources.
  static String get ResourceDir => '{8AD10C31-2ADB-4296-A8F7-E4701232C972}';

  /// The file system directory that serves as a common repository for
  /// application-specific data. A typical path is C:\Documents and
  /// Settings\username\Application Data.
  static String get RoamingAppData => '{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}';

  /// The file system directory that contains Send To menu items. A typical path
  /// is C:\Documents and Settings\username\SendTo.
  static String get SendTo => '{8983036C-27C0-404B-8F08-102D10DCFD74}';

  /// The file system directory that contains Start menu items. A typical path
  /// is C:\Documents and Settings\username\Start Menu.
  static String get StartMenu => '{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}';

  /// The file system directory that corresponds to the user's Startup program
  /// group. The system starts these programs whenever the associated user logs
  /// on. A typical path is C:\Documents and Settings\username\Start
  /// Menu\Programs\Startup.
  static String get Startup => '{B97D20BB-F46A-4C97-BA10-5E3608430854}';

  /// The Windows System folder. A typical path is C:\Windows\System32.
  static String get System => '{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}';

  /// The 32-bit Windows System folder. On 32-bit systems, this is typically
  /// C:\Windows\system32. On 64-bit systems, this is typically
  /// C:\Windows\syswow64.
  static String get SystemX86 => '{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}';

  /// The file system directory that serves as a common repository for document
  /// templates. A typical path is C:\Documents and Settings\username\Templates.
  static String get Templates => '{A63293E8-664E-48DB-A079-DF759E0509F7}';

  /// The file system directory that serves as a common repository for video
  /// files. A typical path is C:\Documents and Settings\username\My
  /// Documents\My Videos.
  static String get Videos => '{18989B1D-99B5-455B-841C-AB7C74E4DDFC}';

  /// The Windows directory or SYSROOT. This corresponds to the %windir% or
  /// %SYSTEMROOT% environment variables. A typical path is C:\Windows.
  static String get Windows => '{F38BF404-1D43-42F2-9305-67DE0B28FC23}';
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Stub version of the actual class.
class WindowsKnownFolder {}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

/// Representation of the Win32 GUID struct.
// For the layout of this struct, see
// https://learn.microsoft.com/windows/win32/api/guiddef/ns-guiddef-guid
@Packed(4)
base class GUID extends Struct {
  /// Native Data1 field.
  @Uint32()
  external int data1;

  /// Native Data2 field.
  @Uint16()
  external int data2;

  /// Native Data3 field.
  @Uint16()
  external int data3;

  /// Native Data4 field.
  // This should be an eight-element byte array, but there's no such annotation.
  @Uint64()
  external int data4;

  /// Parses a GUID string, with optional enclosing "{}"s and optional "-"s,
  /// into data.
  void parse(String guid) {
    final String hexOnly = guid.replaceAll(RegExp(r'[{}-]'), '');
    if (hexOnly.length != 32) {
      throw ArgumentError.value(guid, 'guid', 'Invalid GUID string');
    }
    final ByteData bytes = ByteData(16);
    for (int i = 0; i < 16; ++i) {
      bytes.setUint8(
          i, int.parse(hexOnly.substring(i * 2, i * 2 + 2), radix: 16));
    }
    data1 = bytes.getInt32(0);
    data2 = bytes.getInt16(4);
    data3 = bytes.getInt16(6);
    // [bytes] is big endian, but the host is little endian, so a default
    // big-endian read would reverse the bytes. Since data4 is supposed to be
    // a byte array, the order should be preserved, so do a little-endian read.
    // https://en.wikipedia.org/wiki/Universally_unique_identifier#Encoding
    data4 = bytes.getInt64(8, Endian.little);
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';
import 'package:flutter/foundation.dart' show visibleForTesting;
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

import 'folders.dart';
import 'guid.dart';
import 'win32_wrappers.dart';

/// Constant for en-US language used in VersionInfo keys.
@visibleForTesting
const String languageEn = '0409';

/// Constant for CP1252 encoding used in VersionInfo keys
@visibleForTesting
const String encodingCP1252 = '04e4';

/// Constant for Unicode encoding used in VersionInfo keys
@visibleForTesting
const String encodingUnicode = '04b0';

/// Wraps the Win32 VerQueryValue API call.
///
/// This class exists to allow injecting alternate metadata in tests without
/// building multiple custom test binaries.
@visibleForTesting
class VersionInfoQuerier {
  /// Returns the value for [key] in [versionInfo]s in section with given
  /// language and encoding, or null if there is no such entry,
  /// or if versionInfo is null.
  ///
  /// See https://docs.microsoft.com/windows/win32/menurc/versioninfo-resource
  /// for list of possible language and encoding values.
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    assert(language.isNotEmpty);
    assert(encoding.isNotEmpty);
    if (versionInfo == null) {
      return null;
    }
    final Pointer<Utf16> keyPath =
        '\\StringFileInfo\\$language$encoding\\$key'.toNativeUtf16();
    final Pointer<UINT> length = calloc<UINT>();
    final Pointer<Pointer<Utf16>> valueAddress = calloc<Pointer<Utf16>>();
    try {
      if (VerQueryValue(versionInfo, keyPath, valueAddress, length) == 0) {
        return null;
      }
      return valueAddress.value.toDartString();
    } finally {
      calloc.free(keyPath);
      calloc.free(length);
      calloc.free(valueAddress);
    }
  }
}

/// The Windows implementation of [PathProviderPlatform]
///
/// This class implements the `package:path_provider` functionality for Windows.
class PathProviderWindows extends PathProviderPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// The object to use for performing VerQueryValue calls.
  @visibleForTesting
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// This is typically the same as the TMP environment variable.
  @override
  Future<String?> getTemporaryPath() async {
    final Pointer<Utf16> buffer = calloc<Uint16>(MAX_PATH + 1).cast<Utf16>();
    String path;

    try {
      final int length = GetTempPath(MAX_PATH, buffer);

      if (length == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      } else {
        path = buffer.toDartString();

        // GetTempPath adds a trailing backslash, but SHGetKnownFolderPath does
        // not. Strip off trailing backslash for consistency with other methods
        // here.
        if (path.endsWith(r'\')) {
          path = path.substring(0, path.length - 1);
        }
      }

      // Ensure that the directory exists, since GetTempPath doesn't.
      final Directory directory = Directory(path);
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }

      return path;
    } finally {
      calloc.free(buffer);
    }
  }

  @override
  Future<String?> getApplicationSupportPath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.RoamingAppData);

  @override
  Future<String?> getApplicationDocumentsPath() =>
      getPath(WindowsKnownFolder.Documents);

  @override
  Future<String?> getApplicationCachePath() =>
      _createApplicationSubdirectory(WindowsKnownFolder.LocalAppData);

  @override
  Future<String?> getDownloadsPath() => getPath(WindowsKnownFolder.Downloads);

  /// Retrieve any known folder from Windows.
  ///
  /// folderID is a GUID that represents a specific known folder ID, drawn from
  /// [WindowsKnownFolder].
  Future<String?> getPath(String folderID) {
    final Pointer<Pointer<Utf16>> pathPtrPtr = calloc<Pointer<Utf16>>();
    final Pointer<GUID> knownFolderID = calloc<GUID>()..ref.parse(folderID);

    try {
      final int hr = SHGetKnownFolderPath(
        knownFolderID,
        KF_FLAG_DEFAULT,
        NULL,
        pathPtrPtr,
      );

      if (FAILED(hr)) {
        if (hr == E_INVALIDARG || hr == E_FAIL) {
          throw _createWin32Exception(hr);
        }
        return Future<String?>.value();
      }

      final String path = pathPtrPtr.value.toDartString();
      return Future<String>.value(path);
    } finally {
      calloc.free(pathPtrPtr);
      calloc.free(knownFolderID);
    }
  }

  String? _getStringValue(Pointer<Uint8>? infoBuffer, String key) =>
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingCP1252) ??
      versionInfoQuerier.getStringValue(infoBuffer, key,
          language: languageEn, encoding: encodingUnicode);

  /// Returns the relative path string to append to the root directory returned
  /// by Win32 APIs for application storage (such as RoamingAppDir) to get a
  /// directory that is unique to the application.
  ///
  /// The convention is to use company-name\product-name\. This will use that if
  /// possible, using the data in the VERSIONINFO resource, with the following
  /// fallbacks:
  /// - If the company name isn't there, that component will be dropped.
  /// - If the product name isn't there, it will use the exe's filename (without
  ///   extension).
  String _getApplicationSpecificSubdirectory() {
    String? companyName;
    String? productName;

    final Pointer<Utf16> moduleNameBuffer =
        calloc<WCHAR>(MAX_PATH + 1).cast<Utf16>();
    final Pointer<DWORD> unused = calloc<DWORD>();
    Pointer<BYTE>? infoBuffer;
    try {
      // Get the module name.
      final int moduleNameLength =
          GetModuleFileName(0, moduleNameBuffer, MAX_PATH);
      if (moduleNameLength == 0) {
        final int error = GetLastError();
        throw _createWin32Exception(error);
      }

      // From that, load the VERSIONINFO resource
      final int infoSize = GetFileVersionInfoSize(moduleNameBuffer, unused);
      if (infoSize != 0) {
        infoBuffer = calloc<BYTE>(infoSize);
        if (GetFileVersionInfo(moduleNameBuffer, 0, infoSize, infoBuffer) ==
            0) {
          calloc.free(infoBuffer);
          infoBuffer = null;
        }
      }
      companyName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'CompanyName'));
      productName =
          _sanitizedDirectoryName(_getStringValue(infoBuffer, 'ProductName'));

      // If there was no product name, use the executable name.
      productName ??=
          path.basenameWithoutExtension(moduleNameBuffer.toDartString());

      return companyName != null
          ? path.join(companyName, productName)
          : productName;
    } finally {
      calloc.free(moduleNameBuffer);
      calloc.free(unused);
      if (infoBuffer != null) {
        calloc.free(infoBuffer);
      }
    }
  }

  /// Makes [rawString] safe as a directory component. See
  /// https://docs.microsoft.com/windows/win32/fileio/naming-a-file#naming-conventions
  ///
  /// If after sanitizing the string is empty, returns null.
  String? _sanitizedDirectoryName(String? rawString) {
    if (rawString == null) {
      return null;
    }
    String sanitized = rawString
        // Replace banned characters.
        .replaceAll(RegExp(r'[<>:"/\\|?*]'), '_')
        // Remove trailing whitespace.
        .trimRight()
        // Ensure that it does not end with a '.'.
        .replaceAll(RegExp(r'[.]+$'), '');
    const int kMaxComponentLength = 255;
    if (sanitized.length > kMaxComponentLength) {
      sanitized = sanitized.substring(0, kMaxComponentLength);
    }
    return sanitized.isEmpty ? null : sanitized;
  }

  Future<String?> _createApplicationSubdirectory(String folderId) async {
    final String? baseDir = await getPath(folderId);
    if (baseDir == null) {
      return null;
    }
    final Directory directory =
        Directory(path.join(baseDir, _getApplicationSpecificSubdirectory()));
    // Ensure that the directory exists if possible, since it will on other
    // platforms. If the name is longer than MAXPATH, creating will fail, so
    // skip that step; it's up to the client to decide what to do with the path
    // in that case (e.g., using a short path).
    if (directory.path.length <= MAX_PATH) {
      if (!directory.existsSync()) {
        await directory.create(recursive: true);
      }
    }
    return directory.path;
  }
}

Exception _createWin32Exception(int errorCode) {
  return PlatformException(
      code: 'Win32 Error',
      // TODO(stuartmorgan): Consider getting the system error message via
      // FormatMessage if it turns out to be necessary for debugging issues.
      // Plugin-client-level usability isn't a major consideration since per
      // https://github.com/flutter/flutter/blob/master/docs/ecosystem/contributing/README.md#platform-exception-handling
      // any case that comes up in practice should be handled and returned
      // via a plugin-specific exception, not this fallback.
      message: 'Error code 0x${errorCode.toRadixString(16)}');
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';

/// A stub implementation to satisfy compilation of multi-platform packages that
/// depend on path_provider_windows. This should never actually be created.
///
/// Notably, because path_provider needs to manually register
/// path_provider_windows, anything with a transitive dependency on
/// path_provider will also depend on path_provider_windows, not just at the
/// pubspec level but the code level.
class PathProviderWindows extends PathProviderPlatform {
  /// Errors on attempted instantiation of the stub. It exists only to satisfy
  /// compile-time dependencies, and should never actually be created.
  PathProviderWindows() : assert(false);

  /// Registers the Windows implementation.
  static void registerWith() {
    PathProviderPlatform.instance = PathProviderWindows();
  }

  /// Stub; see comment on VersionInfoQuerier.
  VersionInfoQuerier versionInfoQuerier = VersionInfoQuerier();

  /// Match PathProviderWindows so that the analyzer won't report invalid
  /// overrides if tests provide fake PathProviderWindows implementations.
  Future<String> getPath(String folderID) async => '';
}

/// Stub to satisfy the analyzer, which doesn't seem to handle conditional
/// exports correctly.
class VersionInfoQuerier {}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The types and functions here correspond directly to corresponding Windows
// types and functions, so the Windows docs are the definitive source of
// documentation.
// ignore_for_file: public_member_api_docs

import 'dart:ffi';

import 'package:ffi/ffi.dart';

import 'guid.dart';

typedef BOOL = Int32;
typedef BYTE = Uint8;
typedef DWORD = Uint32;
typedef UINT = Uint32;
typedef HANDLE = IntPtr;
typedef HMODULE = HANDLE;
typedef HRESULT = Int32;
typedef LPCVOID = Pointer<NativeType>;
typedef LPCWSTR = Pointer<Utf16>;
typedef LPDWORD = Pointer<DWORD>;
typedef LPWSTR = Pointer<Utf16>;
typedef LPVOID = Pointer<NativeType>;
typedef PUINT = Pointer<UINT>;
typedef PWSTR = Pointer<Pointer<Utf16>>;
typedef WCHAR = Uint16;

const int NULL = 0;

// https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry
const int MAX_PATH = 260;

// https://learn.microsoft.com/windows/win32/seccrypto/common-hresult-values
// ignore: non_constant_identifier_names
final int E_FAIL = 0x80004005.toSigned(32);
// ignore: non_constant_identifier_names
final int E_INVALIDARG = 0x80070057.toSigned(32);

// https://learn.microsoft.com/windows/win32/api/winerror/nf-winerror-failed#remarks
// ignore: non_constant_identifier_names
bool FAILED(int hr) => hr < 0;

// https://learn.microsoft.com/windows/win32/api/shlobj_core/ne-shlobj_core-known_folder_flag
const int KF_FLAG_DEFAULT = 0x00000000;

final DynamicLibrary _dllKernel32 = DynamicLibrary.open('kernel32.dll');
final DynamicLibrary _dllVersion = DynamicLibrary.open('version.dll');
final DynamicLibrary _dllShell32 = DynamicLibrary.open('shell32.dll');

// https://learn.microsoft.com/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath
typedef _FFITypeSHGetKnownFolderPath = HRESULT Function(
    Pointer<GUID>, DWORD, HANDLE, PWSTR);
typedef FFITypeSHGetKnownFolderPathDart = int Function(
    Pointer<GUID>, int, int, Pointer<Pointer<Utf16>>);
// ignore: non_constant_identifier_names
final FFITypeSHGetKnownFolderPathDart SHGetKnownFolderPath =
    _dllShell32.lookupFunction<_FFITypeSHGetKnownFolderPath,
        FFITypeSHGetKnownFolderPathDart>('SHGetKnownFolderPath');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow
typedef _FFITypeGetFileVersionInfoW = BOOL Function(
    LPCWSTR, DWORD, DWORD, LPVOID);
typedef FFITypeGetFileVersionInfoW = int Function(
    Pointer<Utf16>, int, int, Pointer<NativeType>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoW GetFileVersionInfo = _dllVersion
    .lookupFunction<_FFITypeGetFileVersionInfoW, FFITypeGetFileVersionInfoW>(
        'GetFileVersionInfoW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew
typedef _FFITypeGetFileVersionInfoSizeW = DWORD Function(LPCWSTR, LPDWORD);
typedef FFITypeGetFileVersionInfoSizeW = int Function(
    Pointer<Utf16>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeGetFileVersionInfoSizeW GetFileVersionInfoSize =
    _dllVersion.lookupFunction<_FFITypeGetFileVersionInfoSizeW,
        FFITypeGetFileVersionInfoSizeW>('GetFileVersionInfoSizeW');

// https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
typedef _FFITypeGetLastError = DWORD Function();
typedef FFITypeGetLastError = int Function();
// ignore: non_constant_identifier_names
final FFITypeGetLastError GetLastError = _dllKernel32
    .lookupFunction<_FFITypeGetLastError, FFITypeGetLastError>('GetLastError');

// https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew
typedef _FFITypeGetModuleFileNameW = DWORD Function(HMODULE, LPWSTR, DWORD);
typedef FFITypeGetModuleFileNameW = int Function(int, Pointer<Utf16>, int);
// ignore: non_constant_identifier_names
final FFITypeGetModuleFileNameW GetModuleFileName = _dllKernel32.lookupFunction<
    _FFITypeGetModuleFileNameW,
    FFITypeGetModuleFileNameW>('GetModuleFileNameW');

// https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew
typedef _FFITypeVerQueryValueW = BOOL Function(LPCVOID, LPCWSTR, LPVOID, PUINT);
typedef FFITypeVerQueryValueW = int Function(
    Pointer<NativeType>, Pointer<Utf16>, Pointer<NativeType>, Pointer<Uint32>);
// ignore: non_constant_identifier_names
final FFITypeVerQueryValueW VerQueryValue =
    _dllVersion.lookupFunction<_FFITypeVerQueryValueW, FFITypeVerQueryValueW>(
        'VerQueryValueW');

// https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppathw
typedef _FFITypeGetTempPathW = DWORD Function(DWORD, LPWSTR);
typedef FFITypeGetTempPathW = int Function(int, Pointer<Utf16>);
// ignore: non_constant_identifier_names
final FFITypeGetTempPathW GetTempPath = _dllKernel32
    .lookupFunction<_FFITypeGetTempPathW, FFITypeGetTempPathW>('GetTempPathW');
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// path_provider_windows is implemented using FFI; export a stub for platforms
// that don't support FFI (e.g., web) to avoid having transitive dependencies
// break web compilation.
export 'src/folders_stub.dart' if (dart.library.ffi) 'src/folders.dart';
export 'src/path_provider_windows_stub.dart'
    if (dart.library.ffi) 'src/path_provider_windows_real.dart';
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:typed_data';

import 'package:ffi/ffi.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/src/guid.dart';

void main() {
  test('has correct byte representation', () async {
    final Pointer<GUID> guid = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final ByteData data = ByteData(16)
      ..setInt32(0, guid.ref.data1, Endian.little)
      ..setInt16(4, guid.ref.data2, Endian.little)
      ..setInt16(6, guid.ref.data3, Endian.little)
      ..setInt64(8, guid.ref.data4, Endian.little);
    expect(data.getUint8(0), 0x33);
    expect(data.getUint8(1), 0x22);
    expect(data.getUint8(2), 0x11);
    expect(data.getUint8(3), 0x00);
    expect(data.getUint8(4), 0x55);
    expect(data.getUint8(5), 0x44);
    expect(data.getUint8(6), 0x77);
    expect(data.getUint8(7), 0x66);
    expect(data.getUint8(8), 0x88);
    expect(data.getUint8(9), 0x99);
    expect(data.getUint8(10), 0xAA);
    expect(data.getUint8(11), 0xBB);
    expect(data.getUint8(12), 0xCC);
    expect(data.getUint8(13), 0xDD);
    expect(data.getUint8(14), 0xEE);
    expect(data.getUint8(15), 0xFF);

    calloc.free(guid);
  });

  test('handles alternate forms', () async {
    final Pointer<GUID> guid1 = calloc<GUID>()
      ..ref.parse('{00112233-4455-6677-8899-aabbccddeeff}');
    final Pointer<GUID> guid2 = calloc<GUID>()
      ..ref.parse('00112233445566778899AABBCCDDEEFF');

    expect(guid1.ref.data1, guid2.ref.data1);
    expect(guid1.ref.data2, guid2.ref.data2);
    expect(guid1.ref.data3, guid2.ref.data3);
    expect(guid1.ref.data4, guid2.ref.data4);

    calloc.free(guid1);
    calloc.free(guid2);
  });

  test('throws for bad data', () async {
    final Pointer<GUID> guid = calloc<GUID>();

    expect(() => guid.ref.parse('{00112233-4455-6677-88'), throwsArgumentError);

    calloc.free(guid);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:path_provider_windows/src/path_provider_windows_real.dart'
    show encodingCP1252, encodingUnicode, languageEn;

// A fake VersionInfoQuerier that just returns preset responses.
class FakeVersionInfoQuerier implements VersionInfoQuerier {
  FakeVersionInfoQuerier(
    this.responses, {
    this.language = languageEn,
    this.encoding = encodingUnicode,
  });

  final String language;
  final String encoding;
  final Map<String, String> responses;

  // ignore: unreachable_from_main
  String? getStringValue(
    Pointer<Uint8>? versionInfo,
    String key, {
    required String language,
    required String encoding,
  }) {
    if (language == this.language && encoding == this.encoding) {
      return responses[key];
    } else {
      return null;
    }
  }
}

void main() {
  test('registered instance', () {
    PathProviderWindows.registerWith();
    expect(PathProviderPlatform.instance, isA<PathProviderWindows>());
  });

  test('getTemporaryPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    expect(await pathProvider.getTemporaryPath(), contains(r'C:\'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with no version info', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier =
        FakeVersionInfoQuerier(<String, String>{});
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in CP1252', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with full version info in Unicode', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test(
      'getApplicationSupportPath with full version info in Unsupported Encoding',
      () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, language: '0000', encoding: '0000');
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'AppData'));
    // The last path component should be the executable name.
    expect(path, endsWith(r'flutter_tester'));
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with missing company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'ProductName': 'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with problematic values', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'A <Bad> Company: Name.',
      'ProductName': r'A"/Terrible\|App?*Name',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(
          path,
          endsWith(
              r'AppData\Roaming\A _Bad_ Company_ Name\A__Terrible__App__Name'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with a completely invalid company', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': r'..',
      'ProductName': r'Amazing App',
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Roaming\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getApplicationSupportPath with very long app name', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String truncatedName = 'A' * 255;
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': truncatedName * 2,
    });
    final String? path = await pathProvider.getApplicationSupportPath();
    expect(path, endsWith('\\$truncatedName'));
    // The directory won't exist, since it's longer than MAXPATH, so don't check
    // that here.
  }, skip: !Platform.isWindows);

  test('getApplicationDocumentsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getApplicationDocumentsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Documents'));
  }, skip: !Platform.isWindows);

  test('getApplicationCachePath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    pathProvider.versionInfoQuerier = FakeVersionInfoQuerier(<String, String>{
      'CompanyName': 'A Company',
      'ProductName': 'Amazing App',
    }, encoding: encodingCP1252);
    final String? path = await pathProvider.getApplicationCachePath();
    expect(path, isNotNull);
    if (path != null) {
      expect(path, endsWith(r'AppData\Local\A Company\Amazing App'));
      expect(Directory(path).existsSync(), isTrue);
    }
  }, skip: !Platform.isWindows);

  test('getDownloadsPath', () async {
    final PathProviderWindows pathProvider = PathProviderWindows();
    final String? path = await pathProvider.getDownloadsPath();
    expect(path, contains(r'C:\'));
    expect(path, contains(r'Downloads'));
  }, skip: !Platform.isWindows);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('SharedPreferencesWindows', () {
    late SharedPreferencesWindows preferences;

    const Map<String, Object> flutterTestValues = <String, Object>{
      'flutter.String': 'hello world',
      'flutter.Bool': true,
      'flutter.Int': 42,
      'flutter.Double': 3.14159,
      'flutter.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> prefixTestValues = <String, Object>{
      'prefix.String': 'hello world',
      'prefix.Bool': true,
      'prefix.Int': 42,
      'prefix.Double': 3.14159,
      'prefix.StringList': <String>['foo', 'bar'],
    };

    const Map<String, Object> nonPrefixTestValues = <String, Object>{
      'String': 'hello world',
      'Bool': true,
      'Int': 42,
      'Double': 3.14159,
      'StringList': <String>['foo', 'bar'],
    };

    final Map<String, Object> allTestValues = <String, Object>{};

    allTestValues.addAll(flutterTestValues);
    allTestValues.addAll(prefixTestValues);
    allTestValues.addAll(nonPrefixTestValues);

    Future<void> addData() async {
      await preferences.setValue('String', 'String', allTestValues['String']!);
      await preferences.setValue('Bool', 'Bool', allTestValues['Bool']!);
      await preferences.setValue('Int', 'Int', allTestValues['Int']!);
      await preferences.setValue('Double', 'Double', allTestValues['Double']!);
      await preferences.setValue(
          'StringList', 'StringList', allTestValues['StringList']!);
      await preferences.setValue(
          'String', 'prefix.String', allTestValues['prefix.String']!);
      await preferences.setValue(
          'Bool', 'prefix.Bool', allTestValues['prefix.Bool']!);
      await preferences.setValue(
          'Int', 'prefix.Int', allTestValues['prefix.Int']!);
      await preferences.setValue(
          'Double', 'prefix.Double', allTestValues['prefix.Double']!);
      await preferences.setValue('StringList', 'prefix.StringList',
          allTestValues['prefix.StringList']!);
      await preferences.setValue(
          'String', 'flutter.String', allTestValues['flutter.String']!);
      await preferences.setValue(
          'Bool', 'flutter.Bool', allTestValues['flutter.Bool']!);
      await preferences.setValue(
          'Int', 'flutter.Int', allTestValues['flutter.Int']!);
      await preferences.setValue(
          'Double', 'flutter.Double', allTestValues['flutter.Double']!);
      await preferences.setValue('StringList', 'flutter.StringList',
          allTestValues['flutter.StringList']!);
    }

    setUp(() async {
      preferences = SharedPreferencesWindows();
      await addData();
    });

    tearDown(() async {
      await preferences.clearWithParameters(
        ClearParameters(
          filter: PreferencesFilter(prefix: ''),
        ),
      );
    });

    testWidgets('getAll', (WidgetTester _) async {
      final Map<String, Object> values = await preferences.getAll();
      expect(values['flutter.String'], allTestValues['flutter.String']);
      expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
      expect(values['flutter.Int'], allTestValues['flutter.Int']);
      expect(values['flutter.Double'], allTestValues['flutter.Double']);
      expect(values['flutter.StringList'], allTestValues['flutter.StringList']);
    });

    group('withPrefix', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('prefix.');
        Map<String, Object> values =
            await preferences.getAllWithPrefix('prefix.');
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithPrefix('flutter.');
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithPrefix('');
        final Map<String, Object> values =
            await preferences.getAllWithPrefix('');
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });

    group('withParameters', () {
      testWidgets('remove', (WidgetTester _) async {
        const String key = 'flutter.String';
        await preferences.remove(key);
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values[key], isNull);
      });

      testWidgets('clear', (WidgetTester _) async {
        await preferences.clear();
        final Map<String, Object> values = await preferences.getAll();
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });

      testWidgets('get all with prefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], allTestValues['prefix.StringList']);
      });

      testWidgets('get all with allow list', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.String'},
            ),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
      });

      testWidgets('getAllWithNoPrefix', (WidgetTester _) async {
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], allTestValues['String']);
        expect(values['Bool'], allTestValues['Bool']);
        expect(values['Int'], allTestValues['Int']);
        expect(values['Double'], allTestValues['Double']);
        expect(values['StringList'], allTestValues['StringList']);
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], null);
        expect(values['prefix.Bool'], null);
        expect(values['prefix.Int'], null);
        expect(values['prefix.Double'], null);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithParameters with allow list',
          (WidgetTester _) async {
        await addData();
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(
              prefix: 'prefix.',
              allowList: <String>{'prefix.StringList'},
            ),
          ),
        );
        Map<String, Object> values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'prefix.'),
          ),
        );
        expect(values['prefix.String'], allTestValues['prefix.String']);
        expect(values['prefix.Bool'], allTestValues['prefix.Bool']);
        expect(values['prefix.Int'], allTestValues['prefix.Int']);
        expect(values['prefix.Double'], allTestValues['prefix.Double']);
        expect(values['prefix.StringList'], null);
        values = await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: 'flutter.'),
          ),
        );
        expect(values['flutter.String'], allTestValues['flutter.String']);
        expect(values['flutter.Bool'], allTestValues['flutter.Bool']);
        expect(values['flutter.Int'], allTestValues['flutter.Int']);
        expect(values['flutter.Double'], allTestValues['flutter.Double']);
        expect(
            values['flutter.StringList'], allTestValues['flutter.StringList']);
      });

      testWidgets('clearWithNoPrefix', (WidgetTester _) async {
        await preferences.clearWithParameters(
          ClearParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        final Map<String, Object> values =
            await preferences.getAllWithParameters(
          GetAllParameters(
            filter: PreferencesFilter(prefix: ''),
          ),
        );
        expect(values['String'], null);
        expect(values['Bool'], null);
        expect(values['Int'], null);
        expect(values['Double'], null);
        expect(values['StringList'], null);
        expect(values['flutter.String'], null);
        expect(values['flutter.Bool'], null);
        expect(values['flutter.Int'], null);
        expect(values['flutter.Double'], null);
        expect(values['flutter.StringList'], null);
      });
    });
  });

  group('shared_preferences_async', () {
    const SharedPreferencesWindowsOptions emptyOptions =
        SharedPreferencesWindowsOptions();

    const String stringKey = 'testString';
    const String boolKey = 'testBool';
    const String intKey = 'testInt';
    const String doubleKey = 'testDouble';
    const String listKey = 'testList';

    const String testString = 'hello world';
    const bool testBool = true;
    const int testInt = 42;
    const double testDouble = 3.14159;
    const List<String> testList = <String>['foo', 'bar'];

    Future<SharedPreferencesAsyncPlatform> getPreferences(
        {bool clear = true}) async {
      final SharedPreferencesAsyncPlatform preferences =
          SharedPreferencesAsyncPlatform.instance!;
      if (clear) {
        await preferences.clear(
            const ClearPreferencesParameters(filter: PreferencesFilters()),
            emptyOptions);
      }
      return preferences;
    }

    testWidgets('set and get String', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setString(stringKey, testString, emptyOptions);
      expect(await preferences.getString(stringKey, emptyOptions), testString);
    });

    testWidgets('set and get bool', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setBool(boolKey, testBool, emptyOptions);
      expect(await preferences.getBool(boolKey, emptyOptions), testBool);
    });

    testWidgets('set and get int', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setInt(intKey, testInt, emptyOptions);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
    });

    testWidgets('set and get double', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    });

    testWidgets('set and get StringList', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList does not throw cast error',
        (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      await (preferences as SharedPreferencesAsyncWindows).reload(emptyOptions);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });

    testWidgets('getStringList returns mutable list', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();

      await preferences.setStringList(listKey, testList, emptyOptions);
      final List<String>? list =
          await preferences.getStringList(listKey, emptyOptions);
      list?.add('value');
      expect(list?.length, testList.length + 1);
    });

    testWidgets('getPreferences', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(gotAll.length, 5);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
      expect(gotAll[intKey], testInt);
      expect(gotAll[doubleKey], testDouble);
      expect(gotAll[listKey], testList);
    });

    testWidgets('getPreferences with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(gotAll.length, 2);
      expect(gotAll[stringKey], testString);
      expect(gotAll[boolKey], testBool);
    });

    testWidgets('getKeys', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(keys.length, 5);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
      expect(keys, contains(intKey));
      expect(keys, contains(doubleKey));
      expect(keys, contains(listKey));
    });

    testWidgets('getKeys with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      final Set<String> keys = await preferences.getKeys(
        const GetPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );

      expect(keys.length, 2);
      expect(keys, contains(stringKey));
      expect(keys, contains(boolKey));
    });

    testWidgets('clear', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);

      await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions,
      );

      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), null);
      expect(await preferences.getDouble(doubleKey, emptyOptions), null);
      expect(await preferences.getStringList(listKey, emptyOptions), null);
    });

    testWidgets('clear with filter', (WidgetTester _) async {
      final SharedPreferencesAsyncPlatform preferences = await getPreferences();
      await preferences.setString(stringKey, testString, emptyOptions);
      await preferences.setBool(boolKey, testBool, emptyOptions);
      await preferences.setInt(intKey, testInt, emptyOptions);
      await preferences.setDouble(doubleKey, testDouble, emptyOptions);
      await preferences.setStringList(listKey, testList, emptyOptions);
      await preferences.clear(
        const ClearPreferencesParameters(
          filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
        ),
        emptyOptions,
      );
      expect(await preferences.getString(stringKey, emptyOptions), null);
      expect(await preferences.getBool(boolKey, emptyOptions), null);
      expect(await preferences.getInt(intKey, emptyOptions), testInt);
      expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
      expect(await preferences.getStringList(listKey, emptyOptions), testList);
    });
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'SharedPreferences Demo',
      home: SharedPreferencesDemo(),
    );
  }
}

class SharedPreferencesDemo extends StatefulWidget {
  const SharedPreferencesDemo({super.key});

  @override
  SharedPreferencesDemoState createState() => SharedPreferencesDemoState();
}

class SharedPreferencesDemoState extends State<SharedPreferencesDemo> {
  final SharedPreferencesAsyncPlatform? _prefs =
      SharedPreferencesAsyncPlatform.instance;
  final SharedPreferencesWindowsOptions options =
      const SharedPreferencesWindowsOptions();
  static const String _counterKey = 'counter';
  late Future<int> _counter;

  Future<void> _incrementCounter() async {
    final int? value = await _prefs!.getInt(_counterKey, options);
    final int counter = (value ?? 0) + 1;

    setState(() {
      _counter = _prefs.setInt(_counterKey, counter, options).then((_) {
        return counter;
      });
    });
  }

  Future<void> _getAndSetCounter() async {
    setState(() {
      _counter = _prefs!.getInt(_counterKey, options).then((int? counter) {
        return counter ?? 0;
      });
    });
  }

  @override
  void initState() {
    super.initState();
    _getAndSetCounter();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SharedPreferences Demo'),
      ),
      body: Center(
          child: FutureBuilder<int>(
              future: _counter,
              builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
                switch (snapshot.connectionState) {
                  case ConnectionState.none:
                  case ConnectionState.waiting:
                    return const CircularProgressIndicator();
                  case ConnectionState.active:
                  case ConnectionState.done:
                    if (snapshot.hasError) {
                      return Text('Error: ${snapshot.error}');
                    } else {
                      return Text(
                        'Button tapped ${snapshot.data} time${snapshot.data == 1 ? '' : 's'}.\n\n'
                        'This should persist across restarts.',
                      );
                    }
                }
              })),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'dart:convert' show json;

import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter/foundation.dart' show debugPrint, visibleForTesting;
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_async_platform_interface.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';

const String _defaultFileName = 'shared_preferences';

const String _defaultPrefix = 'flutter.';

/// The Windows implementation of [SharedPreferencesStorePlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
class SharedPreferencesWindows extends SharedPreferencesStorePlatform {
  /// Deprecated instance of [SharedPreferencesWindows].
  /// Use [SharedPreferencesStorePlatform.instance] instead.
  @Deprecated('Use `SharedPreferencesStorePlatform.instance` instead.')
  static SharedPreferencesWindows instance = SharedPreferencesWindows();

  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesStorePlatform.instance = SharedPreferencesWindows();
    // A temporary work-around for having two plugins contained in a single package.
    SharedPreferencesAsyncWindows.registerWith();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences() async {
    _cachedPreferences ??= await _readFromFile(
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }

  @override
  Future<bool> clear() async {
    return clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<bool> clearWithPrefix(String prefix) async {
    return clearWithParameters(
        ClearParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<bool> clearWithParameters(ClearParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;

    final Map<String, Object> preferences = await _readPreferences();
    preferences.removeWhere((String key, _) =>
        key.startsWith(filter.prefix) &&
        (filter.allowList == null || filter.allowList!.contains(key)));
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getAll() async {
    return getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: _defaultPrefix),
      ),
    );
  }

  @override
  Future<Map<String, Object>> getAllWithPrefix(String prefix) async {
    return getAllWithParameters(
        GetAllParameters(filter: PreferencesFilter(prefix: prefix)));
  }

  @override
  Future<Map<String, Object>> getAllWithParameters(
      GetAllParameters parameters) async {
    final PreferencesFilter filter = parameters.filter;
    final Map<String, Object> withPrefix =
        Map<String, Object>.from(await _readPreferences());
    withPrefix.removeWhere((String key, _) => !(key.startsWith(filter.prefix) &&
        (filter.allowList?.contains(key) ?? true)));
    return withPrefix;
  }

  @override
  Future<bool> remove(String key) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences.remove(key);
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<bool> setValue(String valueType, String key, Object value) async {
    final Map<String, Object> preferences = await _readPreferences();
    preferences[key] = value;
    return _writePreferences(
      preferences,
      _defaultFileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }
}

/// The Windows implementation of [SharedPreferencesAsyncPlatform].
///
/// This class implements the `package:shared_preferences` functionality for Windows.
base class SharedPreferencesAsyncWindows
    extends SharedPreferencesAsyncPlatform {
  /// Registers the Windows implementation.
  static void registerWith() {
    SharedPreferencesAsyncPlatform.instance = SharedPreferencesAsyncWindows();
  }

  /// Local copy of preferences
  Map<String, Object>? _cachedPreferences;

  /// File system used to store to disk. Exposed for testing only.
  @visibleForTesting
  FileSystem fs = const LocalFileSystem();

  /// The path_provider_windows instance used to find the support directory.
  @visibleForTesting
  PathProviderWindows pathProvider = PathProviderWindows();

  @override
  Future<Set<String>> getKeys(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return (await getPreferences(parameters, options)).keys.toSet();
  }

  @override
  Future<void> setString(
    String key,
    String value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setBool(
    String key,
    bool value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setDouble(
    String key,
    double value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setInt(
    String key,
    int value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<void> setStringList(
    String key,
    List<String> value,
    SharedPreferencesOptions options,
  ) {
    return _setValue(key, value, options);
  }

  @override
  Future<String?> getString(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as String?;
  }

  @override
  Future<bool?> getBool(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as bool?;
  }

  @override
  Future<double?> getDouble(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as double?;
  }

  @override
  Future<int?> getInt(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return data[key] as int?;
  }

  @override
  Future<List<String>?> getStringList(
    String key,
    SharedPreferencesOptions options,
  ) async {
    final Map<String, Object> data = await _readAll(<String>{key}, options);
    return (data[key] as List<Object?>?)?.cast<String>().toList();
  }

  @override
  Future<void> clear(ClearPreferencesParameters parameters,
      SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final PreferencesFilters filter = parameters.filter;
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences.removeWhere((String key, _) =>
        filter.allowList == null || filter.allowList!.contains(key));
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  @override
  Future<Map<String, Object>> getPreferences(
    GetPreferencesParameters parameters,
    SharedPreferencesOptions options,
  ) async {
    return _readAll(parameters.filter.allowList, options);
  }

  /// Reloads preferences from file.
  @visibleForTesting
  Future<void> reload(
    SharedPreferencesWindowsOptions options,
  ) async {
    _cachedPreferences = await _readFromFile(options.fileName);
  }

  Future<Map<String, Object>> _readAll(
    Set<String>? allowList,
    SharedPreferencesOptions options,
  ) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> prefs = Map<String, Object>.from(
        await _readPreferences(windowsOptions.fileName));
    prefs.removeWhere((String key, _) => !(allowList?.contains(key) ?? true));
    return prefs;
  }

  Future<void> _setValue(
      String key, Object value, SharedPreferencesOptions options) async {
    final SharedPreferencesWindowsOptions windowsOptions =
        SharedPreferencesWindowsOptions.fromSharedPreferencesOptions(options);
    final Map<String, Object> preferences =
        await _readPreferences(windowsOptions.fileName);
    preferences[key] = value;
    await _writePreferences(
      preferences,
      windowsOptions.fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
  }

  /// Checks for cached preferences and returns them or loads preferences from
  /// file and returns and caches them.
  Future<Map<String, Object>> _readPreferences(String fileName) async {
    _cachedPreferences ??= await _readFromFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    return _cachedPreferences!;
  }
}

/// Gets the file where the preferences are stored.
Future<File?> _getLocalDataFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  pathProvider = pathProvider ?? PathProviderWindows();
  final String? directory = await pathProvider.getApplicationSupportPath();
  if (directory == null) {
    return null;
  }
  final String fileLocation = path.join(directory, '$fileName.json');
  return fs.file(fileLocation);
}

/// Gets the preferences from the stored file.
Future<Map<String, Object>> _readFromFile(
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  Map<String, Object> preferences = <String, Object>{};
  final File? localDataFile = await _getLocalDataFile(
    fileName,
    fs: fs,
    pathProvider: pathProvider,
  );
  if (localDataFile != null && localDataFile.existsSync()) {
    final String stringMap = localDataFile.readAsStringSync();
    if (stringMap.isNotEmpty) {
      final Object? data = json.decode(stringMap);
      if (data is Map) {
        preferences = data.cast<String, Object>();
      }
    }
  }
  return preferences;
}

/// Writes the cached preferences to disk. Returns [true] if the operation
/// succeeded.
Future<bool> _writePreferences(
  Map<String, Object> preferences,
  String fileName, {
  FileSystem fs = const LocalFileSystem(),
  PathProviderWindows? pathProvider,
}) async {
  try {
    final File? localDataFile = await _getLocalDataFile(
      fileName,
      fs: fs,
      pathProvider: pathProvider,
    );
    if (localDataFile == null) {
      debugPrint('Unable to determine where to write preferences.');
      return false;
    }
    if (!localDataFile.existsSync()) {
      localDataFile.createSync(recursive: true);
    }
    final String stringMap = json.encode(preferences);
    localDataFile.writeAsStringSync(stringMap);
  } catch (e) {
    debugPrint('Error saving preferences to disk: $e');
    return false;
  }
  return true;
}

/// Windows specific SharedPreferences Options.
class SharedPreferencesWindowsOptions extends SharedPreferencesOptions {
  /// Constructor for SharedPreferencesWindowsOptions.
  const SharedPreferencesWindowsOptions({
    this.fileName = 'shared_preferences', // Same as current defaults.
  });

  /// The name of the file to store preferences in.
  final String fileName;

  /// Returns a new instance of [SharedPreferencesWindowsOptions] from an existing
  /// [SharedPreferencesOptions].
  static SharedPreferencesWindowsOptions fromSharedPreferencesOptions(
      SharedPreferencesOptions options) {
    if (options is SharedPreferencesWindowsOptions) {
      return options;
    }
    return const SharedPreferencesWindowsOptions();
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:path_provider_windows/path_provider_windows.dart';

/// Fake implementation of PathProviderWindows that returns hard-coded paths,
/// allowing tests to run on any platform.
///
/// Note that this should only be used with an in-memory filesystem, as the
/// path it returns is a root path that does not actually exist on Windows.
class FakePathProviderWindows extends PathProviderPlatform
    implements PathProviderWindows {
  @override
  late VersionInfoQuerier versionInfoQuerier;

  @override
  Future<String?> getApplicationSupportPath() async => r'C:\appsupport';

  @override
  Future<String?> getTemporaryPath() async => null;

  @override
  Future<String?> getLibraryPath() async => null;

  @override
  Future<String?> getApplicationDocumentsPath() async => null;

  @override
  Future<String?> getDownloadsPath() async => null;

  @override
  Future<String> getPath(String folderID) async => '';
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:convert';

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/shared_preferences_platform_interface.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesWindows.registerWith();

  const Map<String, Object> flutterTestValues = <String, Object>{
    'flutter.String': 'hello world',
    'flutter.Bool': true,
    'flutter.Int': 42,
    'flutter.Double': 3.14159,
    'flutter.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> prefixTestValues = <String, Object>{
    'prefix.String': 'hello world',
    'prefix.Bool': true,
    'prefix.Int': 42,
    'prefix.Double': 3.14159,
    'prefix.StringList': <String>['foo', 'bar'],
  };

  const Map<String, Object> nonPrefixTestValues = <String, Object>{
    'String': 'hello world',
    'Bool': true,
    'Int': 42,
    'Double': 3.14159,
    'StringList': <String>['foo', 'bar'],
  };

  final Map<String, Object> allTestValues = <String, Object>{};

  allTestValues.addAll(flutterTestValues);
  allTestValues.addAll(prefixTestValues);
  allTestValues.addAll(nonPrefixTestValues);

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  Future<String> getFilePath() async {
    final String? directory = await pathProvider.getApplicationSupportPath();
    return path.join(directory!, 'shared_preferences.json');
  }

  Future<void> writeTestFile(String value) async {
    fs.file(await getFilePath())
      ..createSync(recursive: true)
      ..writeAsStringSync(value);
  }

  Future<String> readTestFile() async {
    return fs.file(await getFilePath()).readAsStringSync();
  }

  SharedPreferencesWindows getPreferences() {
    final SharedPreferencesWindows prefs = SharedPreferencesWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('registered instance', () async {
    SharedPreferencesWindows.registerWith();
    expect(SharedPreferencesStorePlatform.instance,
        isA<SharedPreferencesWindows>());
  });

  test('getAll', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('prefix.');
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(values, hasLength(5));
    expect(values, prefixTestValues);
  });

  test('getAllWithParameters with Prefix with allow list', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String?, Object?> all = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.Bool'},
        ),
      ),
    );
    expect(all.length, 1);
    expect(all['prefix.Bool'], prefixTestValues['prefix.Bool']);
  });

  test('remove', () async {
    await writeTestFile('{"key1":"one","key2":2}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.remove('key2');

    expect(await readTestFile(), '{"key1":"one"}');
  });

  test('setValue', () async {
    await writeTestFile('{}');
    final SharedPreferencesWindows prefs = getPreferences();

    await prefs.setValue('', 'key1', 'one');
    await prefs.setValue('', 'key2', 2);

    expect(await readTestFile(), '{"key1":"one","key2":2}');
  });

  test('clear', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    expect(await readTestFile(), json.encode(flutterTestValues));
    await prefs.clear();
    expect(await readTestFile(), '{}');
  });

  test('clearWithPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('prefix.');
    final Map<String, Object> noValues =
        await prefs.getAllWithPrefix('prefix.');
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithPrefix('');
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithPrefix('');
    final Map<String, Object> noValues = await prefs.getAllWithPrefix('');
    expect(noValues, hasLength(0));
  });

  test('clearWithParameters with Prefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(0));

    final Map<String, Object> values = await prefs.getAll();
    expect(values, hasLength(5));
    expect(values, flutterTestValues);
  });

  test('clearWithParameters with allow list', () async {
    await writeTestFile(json.encode(prefixTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(
          prefix: 'prefix.',
          allowList: <String>{'prefix.StringList'},
        ),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: 'prefix.'),
      ),
    );
    expect(noValues, hasLength(4));
  });

  test('getAllWithNoPrefix', () async {
    await writeTestFile(json.encode(allTestValues));
    final SharedPreferencesWindows prefs = getPreferences();

    final Map<String, Object> values = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(values, hasLength(15));
    expect(values, allTestValues);
  });

  test('clearWithNoPrefix', () async {
    await writeTestFile(json.encode(flutterTestValues));
    final SharedPreferencesWindows prefs = getPreferences();
    await prefs.clearWithParameters(
      ClearParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    final Map<String, Object> noValues = await prefs.getAllWithParameters(
      GetAllParameters(
        filter: PreferencesFilter(prefix: ''),
      ),
    );
    expect(noValues, hasLength(0));
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:file/memory.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_platform_interface/types.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

import 'fake_path_provider_windows.dart';

void main() {
  late MemoryFileSystem fs;
  late PathProviderWindows pathProvider;

  SharedPreferencesAsyncWindows.registerWith();

  const String stringKey = 'testString';
  const String boolKey = 'testBool';
  const String intKey = 'testInt';
  const String doubleKey = 'testDouble';
  const String listKey = 'testList';

  const String testString = 'hello world';
  const bool testBool = true;
  const int testInt = 42;
  const double testDouble = 3.14159;
  const List<String> testList = <String>['foo', 'bar'];

  const SharedPreferencesWindowsOptions emptyOptions =
      SharedPreferencesWindowsOptions();

  setUp(() {
    fs = MemoryFileSystem.test();
    pathProvider = FakePathProviderWindows();
  });

  SharedPreferencesAsyncWindows getPreferences() {
    final SharedPreferencesAsyncWindows prefs = SharedPreferencesAsyncWindows();
    prefs.fs = fs;
    prefs.pathProvider = pathProvider;
    return prefs;
  }

  test('set and get String', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setString(stringKey, testString, emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), testString);
  });

  test('set and get bool', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setBool(boolKey, testBool, emptyOptions);
    expect(await preferences.getBool(boolKey, emptyOptions), testBool);
  });

  test('set and get int', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setInt(intKey, testInt, emptyOptions);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
  });

  test('set and get double', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
  });

  test('set and get StringList', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();

    await preferences.setStringList(listKey, testList, emptyOptions);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });

  test('getPreferences', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);

    expect(gotAll.length, 5);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
    expect(gotAll[intKey], testInt);
    expect(gotAll[doubleKey], testDouble);
    expect(gotAll[listKey], testList);
  });

  test('getPreferences with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Map<String, Object?> gotAll = await preferences.getPreferences(
        const GetPreferencesParameters(
            filter:
                PreferencesFilters(allowList: <String>{stringKey, boolKey})),
        emptyOptions);

    expect(gotAll.length, 2);
    expect(gotAll[stringKey], testString);
    expect(gotAll[boolKey], testBool);
  });

  test('getKeys', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(filter: PreferencesFilters()),
      emptyOptions,
    );

    expect(keys.length, 5);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
    expect(keys, contains(intKey));
    expect(keys, contains(doubleKey));
    expect(keys, contains(listKey));
  });

  test('getKeys with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);

    final Set<String> keys = await preferences.getKeys(
      const GetPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );

    expect(keys.length, 2);
    expect(keys, contains(stringKey));
    expect(keys, contains(boolKey));
  });

  test('clear', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
        const ClearPreferencesParameters(filter: PreferencesFilters()),
        emptyOptions);
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), null);
    expect(await preferences.getDouble(doubleKey, emptyOptions), null);
    expect(await preferences.getStringList(listKey, emptyOptions), null);
  });

  test('clear with filter', () async {
    final SharedPreferencesAsyncWindows preferences = getPreferences();
    await preferences.setString(stringKey, testString, emptyOptions);
    await preferences.setBool(boolKey, testBool, emptyOptions);
    await preferences.setInt(intKey, testInt, emptyOptions);
    await preferences.setDouble(doubleKey, testDouble, emptyOptions);
    await preferences.setStringList(listKey, testList, emptyOptions);
    await preferences.clear(
      const ClearPreferencesParameters(
        filter: PreferencesFilters(allowList: <String>{stringKey, boolKey}),
      ),
      emptyOptions,
    );
    expect(await preferences.getString(stringKey, emptyOptions), null);
    expect(await preferences.getBool(boolKey, emptyOptions), null);
    expect(await preferences.getInt(intKey, emptyOptions), testInt);
    expect(await preferences.getDouble(doubleKey, emptyOptions), testDouble);
    expect(await preferences.getStringList(listKey, emptyOptions), testList);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  testWidgets('canLaunch', (WidgetTester _) async {
    final UrlLauncherPlatform launcher = UrlLauncherPlatform.instance;

    expect(await launcher.canLaunch('randomstring'), false);

    // Generally all devices should have some default browser.
    expect(await launcher.canLaunch('http://flutter.dev'), true);
  });
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  Future<void>? _launched;

  Future<void> _launchInBrowser(String url) async {
    if (await UrlLauncherPlatform.instance.canLaunch(url)) {
      await UrlLauncherPlatform.instance.launch(
        url,
        useSafariVC: false,
        useWebView: false,
        enableJavaScript: false,
        enableDomStorage: false,
        universalLinksOnly: false,
        headers: <String, String>{},
      );
    } else {
      throw Exception('Could not launch $url');
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  @override
  Widget build(BuildContext context) {
    const String toLaunch = 'https://www.cylog.org/headers/';
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(toLaunch),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:integration_test/integration_test_driver.dart';

Future<void> main() => integrationDriver();
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v21.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
}

class UrlLauncherApi {
  /// Constructor for [UrlLauncherApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UrlLauncherApi(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String __pigeon_messageChannelSuffix;

  Future<bool> canLaunchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.canLaunchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<bool> launchUrl(String url) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.url_launcher_windows.UrlLauncherApi.launchUrl$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[url]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'src/messages.g.dart';

/// An implementation of [UrlLauncherPlatform] for Windows.
class UrlLauncherWindows extends UrlLauncherPlatform {
  /// Creates a new plugin implementation instance.
  UrlLauncherWindows({
    @visibleForTesting UrlLauncherApi? api,
  }) : _hostApi = api ?? UrlLauncherApi();

  final UrlLauncherApi _hostApi;

  /// Registers this class as the default instance of [UrlLauncherPlatform].
  static void registerWith() {
    UrlLauncherPlatform.instance = UrlLauncherWindows();
  }

  @override
  final LinkDelegate? linkDelegate = null;

  @override
  Future<bool> canLaunch(String url) {
    return _hostApi.canLaunchUrl(url);
  }

  @override
  Future<bool> launch(
    String url, {
    required bool useSafariVC,
    required bool useWebView,
    required bool enableJavaScript,
    required bool enableDomStorage,
    required bool universalLinksOnly,
    required Map<String, String> headers,
    String? webOnlyWindowName,
  }) async {
    return _hostApi.launchUrl(url);
  }

  @override
  Future<bool> supportsMode(PreferredLaunchMode mode) async {
    return mode == PreferredLaunchMode.platformDefault ||
        mode == PreferredLaunchMode.externalApplication;
  }

  @override
  Future<bool> supportsCloseForMode(PreferredLaunchMode mode) async {
    // No supported mode is closeable.
    return false;
  }
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:pigeon/pigeon.dart';

@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/src/messages.g.dart',
  cppOptions: CppOptions(namespace: 'url_launcher_windows'),
  cppHeaderOut: 'windows/messages.g.h',
  cppSourceOut: 'windows/messages.g.cpp',
  copyrightHeader: 'pigeons/copyright.txt',
))
@HostApi(dartHostTestHandler: 'TestUrlLauncherApi')
abstract class UrlLauncherApi {
  bool canLaunchUrl(String url);
  bool launchUrl(String url);
}
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';
import 'package:url_launcher_windows/src/messages.g.dart';
import 'package:url_launcher_windows/url_launcher_windows.dart';

void main() {
  late _FakeUrlLauncherApi api;
  late UrlLauncherWindows plugin;

  setUp(() {
    api = _FakeUrlLauncherApi();
    plugin = UrlLauncherWindows(api: api);
  });

  test('registers instance', () {
    UrlLauncherWindows.registerWith();
    expect(UrlLauncherPlatform.instance, isA<UrlLauncherWindows>());
  });

  group('canLaunch', () {
    test('handles true', () async {
      api.canLaunch = true;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isTrue);
      expect(api.argument, 'http://example.com/');
    });

    test('handles false', () async {
      api.canLaunch = false;

      final bool result = await plugin.canLaunch('http://example.com/');

      expect(result, isFalse);
      expect(api.argument, 'http://example.com/');
    });
  });

  group('launch', () {
    test('handles success', () async {
      api.canLaunch = true;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          true);
      expect(api.argument, 'http://example.com/');
    });

    test('handles failure', () async {
      api.canLaunch = false;

      expect(
          await plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          false);
      expect(api.argument, 'http://example.com/');
    });

    test('handles errors', () async {
      api.throwError = true;

      await expectLater(
          plugin.launch(
            'http://example.com/',
            useSafariVC: true,
            useWebView: false,
            enableJavaScript: false,
            enableDomStorage: false,
            universalLinksOnly: false,
            headers: const <String, String>{},
          ),
          throwsA(isA<PlatformException>()));
      expect(api.argument, 'http://example.com/');
    });
  });

  group('supportsMode', () {
    test('returns true for platformDefault', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(await launcher.supportsMode(PreferredLaunchMode.platformDefault),
          true);
    });

    test('returns true for external application', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.externalApplication),
          true);
    });

    test('returns false for other modes', () async {
      final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
      expect(
          await launcher
              .supportsMode(PreferredLaunchMode.externalNonBrowserApplication),
          false);
      expect(await launcher.supportsMode(PreferredLaunchMode.inAppBrowserView),
          false);
      expect(
          await launcher.supportsMode(PreferredLaunchMode.inAppWebView), false);
    });
  });

  test('supportsCloseForMode returns false', () async {
    final UrlLauncherWindows launcher = UrlLauncherWindows(api: api);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.platformDefault),
        false);
    expect(
        await launcher
            .supportsCloseForMode(PreferredLaunchMode.externalApplication),
        false);
  });
}

class _FakeUrlLauncherApi implements UrlLauncherApi {
  /// The argument that was passed to an API call.
  String? argument;

  /// Controls the behavior of the fake canLaunch implementations.
  ///
  /// - [canLaunchUrl] returns this value.
  /// - [launchUrl] returns this value if [throwError] is false.
  bool canLaunch = false;

  /// Whether to throw a platform exception.
  bool throwError = false;

  @override
  Future<bool> canLaunchUrl(String url) async {
    argument = url;
    return canLaunch;
  }

  @override
  Future<bool> launchUrl(String url) async {
    argument = url;
    if (throwError) {
      throw PlatformException(code: 'Failed');
    }
    return canLaunch;
  }
}
